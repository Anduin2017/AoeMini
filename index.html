<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Êú¥Á¥†Â∏ùÂõΩ - Minimalist Empire</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ‰øùÊåÅÂéüÊúâÁöÑ CSS ‰∏çÂèò */
        body {
            background-color: #111;
            color: #e5e5e5;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            user-select: none;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #game-wrapper {
            position: relative;
            flex: 1;
            overflow: hidden;
            background: #262626;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* --- ÂõæÂ±ÇÁÆ°ÁêÜ --- */
        #bgCanvas {
            z-index: 5;
        }

        /* 2. Âü∫Âú∞ - ‰øÆÊîπ‰∏∫ÂüéÂ†°Ê†∑Âºè */
        .base {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 64px;
            /* Ê†∏ÂøÉ‰ΩìÁßØ */
            height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            font-weight: bold;
            font-size: 0.8rem;
            z-index: 10;
            pointer-events: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            border-radius: 8px 8px 4px 4px;
            padding-top: 10px;
        }

        .base::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 26px;
            height: 36px;
            background: #1a1a1a;
            border: 2px solid #444;
            border-bottom: none;
            border-radius: 13px 13px 0 0;
            box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.8);
        }

        #gameCanvas {
            z-index: 15;
        }

        .floater {
            position: absolute;
            color: white;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 1px 1px 2px black;
            z-index: 100;
        }

        .base-player {
            left: 12px;
            background: linear-gradient(to bottom, #3b82f6, #1d4ed8);
            border: 2px solid #1e3a8a;
            border-bottom: 4px solid #1e3a8a;
        }

        .base-enemy {
            right: 12px;
            background: linear-gradient(to bottom, #ef4444, #b91c1c);
            border: 2px solid #7f1d1d;
            border-bottom: 4px solid #7f1d1d;
        }

        .turret-addon {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 15px;
            background-color: #4b5563;
            border: 2px solid #9ca3af;
            border-radius: 4px 4px 0 0;
            display: none;
            z-index: 2;
        }

        .turret-addon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background-color: #000;
            border-radius: 50%;
        }

        .has-turret .turret-addon {
            display: block;
        }

        .hp-bar-container {
            position: absolute;
            top: -25px;
            width: 120%;
            left: -10%;
            height: 6px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .hp-bar-fill {
            height: 100%;
            background: #22c55e;
            width: 100%;
            transition: width 0.2s;
        }

        .base-label {
            position: absolute;
            top: 4px;
            z-index: 3;
            text-shadow: 1px 1px 2px black;
        }

        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px 20px;
            pointer-events: none;
            z-index: 20;
        }

        .top-group {
            display: flex;
            flex-direction: column;
        }

        .top-group.right {
            align-items: flex-end;
        }

        .top-item {
            font-weight: bold;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px black;
            line-height: 1.2;
        }

        .tech-status {
            font-family: monospace;
            font-size: 0.8rem;
            font-weight: bold;
            margin-top: 2px;
            text-shadow: 1px 1px 1px black;
            opacity: 0.9;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px 8px;
        }

        .text-blue {
            color: #60a5fa;
        }

        .text-red {
            color: #f87171;
        }

        .text-blue-light {
            color: #93c5fd;
        }

        .text-red-light {
            color: #fca5a5;
        }

        .tactics-bar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 30;
            pointer-events: auto;
        }

        .tactic-btn {
            background: rgba(30, 30, 30, 0.6);
            border: 1px solid #555;
            color: #ccc;
            padding: 6px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
            font-size: 0.85rem;
        }

        .tactic-btn:hover {
            background: #444;
            color: white;
        }

        .tactic-btn.active {
            background: #2563eb;
            border-color: #60a5fa;
            color: white;
            box-shadow: 0 0 8px #2563eb;
        }

        .resource-widget {
            position: absolute;
            bottom: 100px;
            left: 20px;
            width: 280px;
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            z-index: 40;
            backdrop-filter: blur(8px);
        }

        @media (max-height: 500px) {
            .resource-widget {
                bottom: 90px;
                left: 10px;
                transform: scale(0.9);
                transform-origin: bottom left;
            }
        }

        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            margin-bottom: 8px;
            border-bottom: 1px solid #4b5563;
            font-size: 1rem;
        }

        .status-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .icon-house {
            color: #f59e0b;
        }

        .pop-text {
            font-weight: bold;
            font-family: monospace;
            transition: color 0.2s;
        }

        /* ÊÅ¢Â§çÁöÑ‰∫∫Âè£Êª°Êó∂ÁöÑÈó™ÁÉÅÂä®ÁîªÁ±ª */
        .pop-text.warning {
            color: #ef4444;
            animation: pulse 1s infinite;
        }

        .icon-sleep {
            color: #9ca3af;
        }

        .idle-text {
            color: #9ca3af;
            font-weight: bold;
            font-family: monospace;
        }

        .idle-text.warning {
            color: #ef4444;
            animation: pulse 1s infinite;
        }

        .res-grid {
            display: grid;
            grid-template-columns: 24px 1fr 24px 50px 24px;
            gap: 4px;
            align-items: center;
            font-size: 0.9rem;
        }

        .res-icon {
            text-align: center;
            font-size: 1rem;
        }

        .res-val {
            font-family: monospace;
            text-align: right;
            padding-right: 10px;
            color: #e5e5e5;
            font-weight: bold;
        }

        .worker-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            height: 24px;
        }

        .res-w-icon {
            color: #9ca3af;
            font-size: 0.7rem;
        }

        .res-w-val {
            color: #60a5fa;
            font-family: monospace;
            font-weight: bold;
        }

        .tiny-btn {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #374151;
            border: 1px solid #4b5563;
            border-radius: 4px;
            cursor: pointer;
            color: #ccc;
            font-size: 0.9rem;
            line-height: 0;
            transition: background 0.1s;
        }

        .tiny-btn:hover {
            background: #4b5563;
            color: white;
        }

        .tiny-btn.disabled {
            opacity: 0.2;
            cursor: default;
            pointer-events: none;
        }

        .dock-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 8px;
            border-radius: 16px;
            display: flex;
            gap: 12px;
            z-index: 50;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            max-width: 95vw;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .dock-container::-webkit-scrollbar {
            display: none;
        }

        .dock-icon {
            width: 56px;
            height: 56px;
            background: #2d2d2d;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            cursor: pointer;
            position: relative;
            transition: transform 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: 1px solid #444;
            flex-shrink: 0;
        }

        .dock-icon:hover {
            transform: translateY(-5px) scale(1.1);
            background: #3d3d3d;
            z-index: 60;
        }

        .dock-icon.active {
            background: #333;
            box-shadow: 0 0 0 2px #3b82f6;
            transform: translateY(-5px);
        }

        .dock-icon.build-icon {
            background: #eab308;
            color: #000;
            border-color: #ca8a04;
        }

        .dock-icon.build-icon:hover {
            background: #facc15;
        }

        .dock-icon.constructing {
            opacity: 0.7;
            border-style: dashed;
            background: #1f2937;
        }

        .dock-icon.constructing .const-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            font-size: 12px;
            color: #eab308;
            font-weight: bold;
        }

        .icon-progress-bg {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            overflow: hidden;
            display: none;
        }

        .icon-progress-fill {
            height: 100%;
            width: 0%;
            background: #3b82f6;
            transition: width linear 0.1s;
        }

        .constructing .icon-progress-fill {
            background: #eab308;
        }

        .dock-icon.researching .icon-progress-fill {
            background: #22c55e;
        }

        .icon-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ef4444;
            color: white;
            font-size: 10px;
            font-weight: bold;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 2px black;
        }

        .icon-badge.house-badge {
            background: #eab308;
            color: #000;
        }

        .popover-menu {
            position: absolute;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid #4b5563;
            border-radius: 8px;
            padding: 10px;
            min-width: 180px;
            display: none;
            flex-direction: column;
            gap: 8px;
            z-index: 60;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(12px);
        }

        .popover-menu::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
            width: 12px;
            height: 12px;
            background: rgba(31, 41, 55, 0.95);
            border-right: 1px solid #4b5563;
            border-bottom: 1px solid #4b5563;
        }

        .popover-title {
            font-size: 0.8rem;
            color: #9ca3af;
            text-transform: uppercase;
            border-bottom: 1px solid #4b5563;
            padding-bottom: 4px;
            margin-bottom: 4px;
            text-align: center;
        }

        .menu-btn {
            background: #374151;
            border: 1px solid #4b5563;
            color: white;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            transition: all 0.1s;
        }

        .menu-btn:hover:not(:disabled) {
            background: #4b5563;
        }

        .menu-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .btn-icon {
            font-size: 1.4rem;
        }

        .btn-info {
            display: flex;
            flex-direction: column;
            line-height: 1.2;
            text-align: left;
        }

        .btn-cost {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        .menu-btn.tech-btn {
            border-color: #8b5cf6;
            background: rgba(139, 92, 246, 0.1);
        }

        .menu-btn.tech-btn:hover:not(:disabled) {
            background: rgba(139, 92, 246, 0.3);
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            display: none;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-30px);
                opacity: 0;
            }
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        #unit-tooltip {
            position: absolute;
            background: rgba(17, 24, 39, 0.95);
            border: 1px solid #4b5563;
            padding: 8px 12px;
            border-radius: 6px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            color: white;
            font-size: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            min-width: 140px;
        }

        .tt-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }

        .tt-header {
            font-weight: bold;
            color: #60a5fa;
            border-bottom: 1px solid #4b5563;
            margin-bottom: 4px;
            padding-bottom: 2px;
            text-align: center;
        }

        .tt-enemy .tt-header {
            color: #f87171;
        }

        .tt-sub {
            color: #9ca3af;
            font-size: 11px;
        }

        .val-bonus {
            color: #22c55e;
            margin-left: 2px;
        }
    </style>
</head>

<body>

    <div id="toast-container" class="fixed top-4 left-1/2 transform -translate-x-1/2 z-50"></div>

    <div class="top-bar">
        <div class="top-group">
            <div class="top-item text-blue">Áé©ÂÆ∂</div>
            <div class="tech-status text-blue-light">
                <span id="p-tech-atk-m" title="ËøëÊàòÊîªÂáª">‚öîÔ∏è 0</span>
                <span id="p-tech-def-m" title="ËøëÊàòÈò≤Âæ°">üõ°Ô∏è 0</span>
                <span id="p-tech-atk-r" title="ËøúÁ®ãÊîªÂáª">üèπ 0</span>
                <span id="p-tech-def-r" title="ËøúÁ®ãÈò≤Âæ°">üéØ 0</span>
            </div>
        </div>

        <div class="top-group right">
            <div class="top-item text-red">ÁîµËÑë</div>
            <div class="tech-status text-red-light">
                <span id="e-tech-atk-m" title="ËøëÊàòÊîªÂáª">‚öîÔ∏è 0</span>
                <span id="e-tech-def-m" title="ËøëÊàòÈò≤Âæ°">üõ°Ô∏è 0</span>
                <span id="e-tech-atk-r" title="ËøúÁ®ãÊîªÂáª">üèπ 0</span>
                <span id="e-tech-def-r" title="ËøúÁ®ãÈò≤Âæ°">üéØ 0</span>
            </div>
        </div>
    </div>

    <div id="game-wrapper">
        <div class="tactics-bar">
            <button id="btn-stance-defend" class="tactic-btn" onclick="game.setPlayerStance('defend')">üõ°Ô∏è Èò≤ÂÆà</button>
            <button id="btn-stance-hold" class="tactic-btn" onclick="game.setPlayerStance('hold')">‚úã ÂæÖÂëΩ</button>
            <button id="btn-stance-attack" class="tactic-btn active" onclick="game.setPlayerStance('attack')">‚öîÔ∏è
                ËøõÊîª</button>
        </div>
        <canvas id="bgCanvas"></canvas>
        <canvas id="gameCanvas"></canvas>

        <div id="unit-tooltip"></div>

        <div id="p-base" class="base base-player">
            <div class="turret-addon"></div>
            <div class="hp-bar-container">
                <div id="p-base-hp" class="hp-bar-fill"></div>
            </div>
            <div class="base-label">Âü∫Âú∞</div>
        </div>
        <div id="e-base" class="base base-enemy">
            <div class="turret-addon"></div>
            <div class="hp-bar-container">
                <div id="e-base-hp" class="hp-bar-fill"></div>
            </div>
            <div class="base-label">ÁîµËÑë</div>
        </div>
    </div>

    <div id="ui-layer">
        <div class="resource-widget">
            <div class="status-header">
                <div class="status-group" title="‰∫∫Âè£">
                    <span class="icon-house">üè†</span> <span id="disp-pop" class="pop-text">0/200</span>
                </div>
                <div class="status-group" title="Á©∫Èó≤ÊùëÊ∞ë">
                    <span class="icon-sleep">üí§</span> <span id="disp-idle" class="idle-text">0</span>
                </div>
            </div>
            <div class="res-grid">
                <div class="res-icon">ü•©</div>
                <div class="res-val" id="res-stock-food">0</div>
                <div class="tiny-btn" id="sub-food" onclick="game.modWork('food',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">üë§</span><span class="res-w-val"
                        id="res-workers-food">0</span></div>
                <div class="tiny-btn" id="add-food" onclick="game.modWork('food',1)">+</div>

                <div class="res-icon">üå≤</div>
                <div class="res-val" id="res-stock-wood">0</div>
                <div class="tiny-btn" id="sub-wood" onclick="game.modWork('wood',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">üë§</span><span class="res-w-val"
                        id="res-workers-wood">0</span></div>
                <div class="tiny-btn" id="add-wood" onclick="game.modWork('wood',1)">+</div>

                <div class="res-icon">ü™ô</div>
                <div class="res-val" id="res-stock-gold">0</div>
                <div class="tiny-btn" id="sub-gold" onclick="game.modWork('gold',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">üë§</span><span class="res-w-val"
                        id="res-workers-gold">0</span></div>
                <div class="tiny-btn" id="add-gold" onclick="game.modWork('gold',1)">+</div>

                <div class="res-icon">ü™®</div>
                <div class="res-val" id="res-stock-stone">0</div>
                <div class="tiny-btn" id="sub-stone" onclick="game.modWork('stone',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">üë§</span><span class="res-w-val"
                        id="res-workers-stone">0</span></div>
                <div class="tiny-btn" id="add-stone" onclick="game.modWork('stone',1)">+</div>
            </div>
        </div>

        <div class="dock-container" id="dock">
            <div class="dock-icon build-icon" id="dock-build_menu" onclick="game.toggleDockItem('build_menu')">
                üî®
            </div>
        </div>

        <div id="popover-container" class="popover-menu"></div>
    </div>

    <div id="game-over">
        <h1 id="end-title" class="text-5xl font-bold mb-4 text-white">GAME OVER</h1>
        <p id="end-reason" class="text-xl text-gray-300 mb-8">Reason</p>
        <button onclick="location.reload()"
            class="px-6 py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded">ÂÜçÊù•‰∏ÄÂ±Ä</button>
    </div>

    <script>
        const TICK_RATE = 100;
        const MAX_QUEUE_SIZE = 5;
        const MAX_TOTAL_POP = 200;
        const BASE_RANGE = 5;

        const CONSTANTS = {
            INITIAL_RES: { food: 200, wood: 200, gold: 100, stone: 0 },
            BASE_HP: 2000, INITIAL_POP_CAP: 10,
            MAP_WIDTH_PERCENT: 100,
            UNIT_SIZE_PERCENT: 0.8,
            BASE_WIDTH_PX: 64, // Âü∫Âú∞ËßÜËßâÂÆΩÂ∫¶
            BASE_OFFSET_PX: 12, // Âü∫Âú∞Ë∑ùÁ¶ªËæπÁºòÁöÑÂÅèÁßªÈáè
            UNITS: {
                worker: { cost: { food: 50, wood: 0 }, time: 200, hp: 10, dmg: 0, def_m: 0, def_r: 0, type: 'eco', label: 'ÊùëÊ∞ë', lane: 0, stopOnAttack: false },
                clubman: { cost: { food: 60, wood: 20 }, time: 150, hp: 90, dmg: 8, def_m: 0, def_r: 0, speed: 1.25, type: 'mil', label: 'ÈïøÊû™ÂÖµ', range: BASE_RANGE, lane: 0, stopOnAttack: false, attackType: 'melee', cooldown: 19 },
                samurai: { cost: { food: 100, wood: 0, gold: 20 }, time: 150, hp: 140, dmg: 11, def_m: 2, def_r: 3, speed: 1.125, type: 'mil', label: 'Ê≠¶Â£´', range: BASE_RANGE * 0.75, lane: 0, stopOnAttack: false, attackType: 'melee', cooldown: 14 },
                longbowman: { cost: { food: 40, wood: 50, gold: 0 }, time: 150, hp: 70, dmg: 6, def_m: 0, def_r: 0, speed: 1.125, type: 'mil', label: 'ÈïøÂºìÂÖµ', range: BASE_RANGE * 3, lane: 1, widthScale: 0.5, stopOnAttack: true, attackType: 'ranged', cooldown: 16 }
            },
            BUILDINGS: {
                house: { cost: { food: 0, wood: 50, stone: 0 }, pop: 10, time: 150, label: 'ÊàøÂ±ã', icon: 'üè†' },
                barracks: { cost: { food: 0, wood: 150, stone: 0 }, time: 300, label: 'ÂÖµËê•', icon: '‚öîÔ∏è' },
                archery_range: { cost: { food: 0, wood: 150, stone: 0 }, time: 300, label: 'Èù∂Âú∫', icon: 'üèπ' },
                towncenter: { cost: { food: 0, wood: 400, stone: 350 }, pop: 10, time: 1200, label: 'Âü∫Âú∞', icon: 'üèõÔ∏è' },
                blacksmith: { cost: { food: 0, wood: 150, stone: 0 }, time: 250, label: 'ÈìÅÂå†Èì∫', icon: '‚öíÔ∏è' }
            },
            TECHS: {
                turret_tech: { cost: { food: 0, wood: 0, gold: 100, stone: 170 }, time: 240, label: 'Èò≤Âæ°ÁÇÆÂè∞', icon: 'üèØ', desc: 'Âü∫Âú∞Ëé∑ÂæóÂº∫Â§ßÈò≤Âæ°Âäõ' },
                tech_atk_m_1: { cost: { food: 50, wood: 0, gold: 125, stone: 0 }, time: 600, label: 'ËøëÊàòÊîªÂáª I', icon: '‚öîÔ∏è', level: 1, type: 'atk_m' },
                tech_atk_m_2: { cost: { food: 100, wood: 0, gold: 250, stone: 0 }, time: 600, label: 'ËøëÊàòÊîªÂáª II', icon: '‚öîÔ∏è', level: 2, type: 'atk_m' },
                tech_atk_m_3: { cost: { food: 150, wood: 0, gold: 300, stone: 0 }, time: 600, label: 'ËøëÊàòÊîªÂáª III', icon: '‚öîÔ∏è', level: 3, type: 'atk_m' },
                tech_def_m_1: { cost: { food: 50, wood: 0, gold: 125, stone: 0 }, time: 600, label: 'ËøëÊàòÈò≤Âæ° I', icon: 'üõ°Ô∏è', level: 1, type: 'def_m' },
                tech_def_m_2: { cost: { food: 100, wood: 0, gold: 250, stone: 0 }, time: 600, label: 'ËøëÊàòÈò≤Âæ° II', icon: 'üõ°Ô∏è', level: 2, type: 'def_m' },
                tech_def_m_3: { cost: { food: 150, wood: 0, gold: 300, stone: 0 }, time: 600, label: 'ËøëÊàòÈò≤Âæ° III', icon: 'üõ°Ô∏è', level: 3, type: 'def_m' },
                tech_atk_r_1: { cost: { food: 0, wood: 50, gold: 125, stone: 0 }, time: 600, label: 'ËøúÁ®ãÊîªÂáª I', icon: 'üèπ', level: 1, type: 'atk_r' },
                tech_atk_r_2: { cost: { food: 0, wood: 100, gold: 250, stone: 0 }, time: 600, label: 'ËøúÁ®ãÊîªÂáª II', icon: 'üèπ', level: 2, type: 'atk_r' },
                tech_atk_r_3: { cost: { food: 0, wood: 150, gold: 300, stone: 0 }, time: 600, label: 'ËøúÁ®ãÊîªÂáª III', icon: 'üèπ', level: 3, type: 'atk_r' },
                tech_def_r_1: { cost: { food: 0, wood: 50, gold: 125, stone: 0 }, time: 600, label: 'ËøúÁ®ãÈò≤Âæ° I', icon: 'üéØ', level: 1, type: 'def_r' },
                tech_def_r_2: { cost: { food: 0, wood: 100, gold: 250, stone: 0 }, time: 600, label: 'ËøúÁ®ãÈò≤Âæ° II', icon: 'üéØ', level: 2, type: 'def_r' },
                tech_def_r_3: { cost: { food: 0, wood: 150, gold: 300, stone: 0 }, time: 600, label: 'ËøúÁ®ãÈò≤Âæ° III', icon: 'üéØ', level: 3, type: 'def_r' }
            }
        };

        class Entity {
            constructor(type, owner, id, spawnPos) {
                this.id = id; this.type = type; this.owner = owner;
                const uData = CONSTANTS.UNITS[type];
                this.maxHp = uData.hp;
                this.hp = this.maxHp;
                this.dmg = uData.dmg || 0;
                this.def_m = uData.def_m || 0;
                this.def_r = uData.def_r || 0;
                this.speed = (uData.speed || 0) / (1000 / TICK_RATE);
                this.pos = spawnPos; // ÂàùÂßã‰ΩçÁΩÆÁé∞Âú®ÊòØÈó®ÂÜÖ
                this.state = 'move';
                this.width = CONSTANTS.UNIT_SIZE_PERCENT * (uData.widthScale || 1);
                this.range = uData.range || BASE_RANGE;
                this.lane = uData.lane !== undefined ? uData.lane : 0;
                this.stopOnAttack = uData.stopOnAttack !== undefined ? uData.stopOnAttack : false;
                this.attackCooldown = Math.floor(Math.random() * 10); this.attackAnimTimer = 0;
                this.isDeployed = false; // Âè™ÊúâËµ∞Âá∫Âü∫Âú∞Â¢ôÂ£ÅÂêéÊâçÁÆóÈÉ®ÁΩ≤ÔºåÈÉ®ÁΩ≤ÂêéÊó†Ê≥ïÂõûÂüé
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.bgCanvas = document.getElementById('bgCanvas');
                this.bgCtx = this.bgCanvas.getContext('2d');

                this.baseWidthPct = 6; // ÂàùÂßãÂåñÈªòËÆ§ÂÄº
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.lastTick = 0; this.entityIdCounter = 0; this.buildingIdCounter = 0; this.constructionIdCounter = 0; this.gameOver = false;

                this.state = {
                    tick: 0,
                    player: this.createFactionState('player'),
                    enemy: this.createFactionState('enemy'),
                    units: [],
                    playerStance: 'attack',
                    enemyStance: 'attack',
                    selectedDockId: null,
                    turretShots: []
                };

                window.addEventListener('click', (e) => {
                    if (!e.target.closest('.dock-icon') && !e.target.closest('.popover-menu')) this.closePopover();
                });

                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseleave', () => { document.getElementById('unit-tooltip').style.display = 'none'; });

                this.renderDock();
                this.logicInterval = setInterval(() => this.updateLogic(), TICK_RATE);
                setInterval(() => this.debugAI(), 3000);
                requestAnimationFrame(() => this.loop());
            }

            handleMouseMove(e) {
                if (this.gameOver) return;
                const rect = this.canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                const w = this.canvas.width;
                const h = this.canvas.height;

                let foundUnit = null;
                for (const u of this.state.units) {
                    const unitX = (u.pos / 100) * w;
                    const laneY = u.lane === 1 ? (h / 2 - 20) : (h / 2 + 20);

                    if (Math.abs(mx - unitX) < 15 && Math.abs(my - laneY) < 20) {
                        foundUnit = u;
                        break;
                    }
                }
                const tt = document.getElementById('unit-tooltip');

                if (foundUnit) {
                    const uData = CONSTANTS.UNITS[foundUnit.type];
                    const isPlayer = foundUnit.owner === 'player';
                    const colorClass = isPlayer ? '' : 'tt-enemy';
                    const baseDmg = uData.dmg;
                    const bonusDmg = foundUnit.dmg - baseDmg;

                    tt.className = colorClass;
                    tt.innerHTML = `
                        <div class="tt-header">${uData.label} (${isPlayer ? 'ÊàëÊñπ' : 'ÊïåÊñπ'})</div>
                        <div class="tt-row"><span>‚ù§Ô∏è ÁîüÂëΩ:</span> <span>${Math.ceil(foundUnit.hp)}/${foundUnit.maxHp}</span></div>
                        <div class="tt-row"><span>üó°Ô∏è Âü∫Á°ÄÊîªÂáª:</span> <span>${baseDmg}</span></div>
                        <div class="tt-row"><span>üî• ÊîªÂáªÂä†Êàê:</span> <span class="val-bonus">+${bonusDmg}</span></div>
                        <div class="tt-row"><span>üõ°Ô∏è ËøëÊàòÈò≤Âæ°:</span> <span>${foundUnit.def_m}</span></div>
                        <div class="tt-row"><span>üéØ ËøúÁ®ãÈò≤Âæ°:</span> <span>${foundUnit.def_r}</span></div>
                    `;
                    tt.style.left = (e.clientX + 15) + 'px';
                    tt.style.top = (e.clientY + 15) + 'px';
                    tt.style.display = 'block';
                } else {
                    let foundBase = null;
                    const baseYTop = h / 2 - 40;
                    const baseYBottom = h / 2 + 40;
                    const basePxW = CONSTANTS.BASE_WIDTH_PX + CONSTANTS.BASE_OFFSET_PX;

                    if (my >= baseYTop && my <= baseYBottom) {
                        if (mx >= 0 && mx <= basePxW) {
                            foundBase = this.state.player;
                        } else if (mx >= w - basePxW && mx <= w) {
                            foundBase = this.state.enemy;
                        }
                    }

                    if (foundBase) {
                        const isPlayer = foundBase.name === 'player';
                        const colorClass = isPlayer ? '' : 'tt-enemy';
                        const turretDmg = foundBase.hasTurret ? (CONSTANTS.UNITS.clubman.dmg * 1.5) : 0;
                        tt.className = colorClass;
                        tt.innerHTML = `
                            <div class="tt-header">${isPlayer ? 'ÊàëÊñπ' : 'ÊïåÊñπ'}Âü∫Âú∞</div>
                            <div class="tt-row"><span>‚ù§Ô∏è ÁîüÂëΩ:</span> <span>${Math.ceil(foundBase.baseHp)}/${CONSTANTS.BASE_HP}</span></div>
                            <div class="tt-row"><span>üõ°Ô∏è ËøëÊàòÈò≤Âæ°:</span> <span>2</span></div>
                            <div class="tt-row"><span>üéØ ËøúÁ®ãÈò≤Âæ°:</span> <span>2</span></div>
                            ${foundBase.hasTurret ? `<div class="tt-row"><span>‚öîÔ∏è ÁÇÆÂè∞:</span> <span>${turretDmg}</span></div>` : ''}
                        `;
                        tt.style.left = (e.clientX + 15) + 'px';
                        tt.style.top = (e.clientY + 15) + 'px';
                        tt.style.display = 'block';
                    } else {
                        tt.style.display = 'none';
                    }
                }
            }

            debugAI() {
                if (this.gameOver) return;
                const ai = this.state.enemy;
                console.groupCollapsed(`ü§ñ AI Áä∂ÊÄÅÁõëÊéß (Tick: ${this.state.tick})`);
                console.log(`üí∞ ËµÑÊ∫ê: F${Math.floor(ai.food)} W${Math.floor(ai.wood)} G${Math.floor(ai.gold)} S${Math.floor(ai.stone)}`);
                console.groupEnd();
            }

            createFactionState(name) {
                const initialBuildings = [{ id: `${name}-b-${this.buildingIdCounter++}`, type: 'towncenter', queue: [] }];
                let initialWorkers = 6;
                if (name === 'enemy') initialWorkers = 7;
                return {
                    name: name,
                    food: CONSTANTS.INITIAL_RES.food, wood: CONSTANTS.INITIAL_RES.wood, gold: CONSTANTS.INITIAL_RES.gold, stone: CONSTANTS.INITIAL_RES.stone,
                    idleWorkers: 0, assignments: { food: initialWorkers, wood: 0, gold: 0, stone: 0 }, workers: initialWorkers,
                    popCap: CONSTANTS.INITIAL_POP_CAP, baseHp: CONSTANTS.BASE_HP,
                    buildingInstances: initialBuildings, constructions: [], armyCount: 0,
                    hasTurret: false, turretCooldown: 0,
                    techLevels: { atk_m: 0, def_m: 0, atk_r: 0, def_r: 0 }
                };
            }

            resizeCanvas() {
                const wrapper = document.getElementById('game-wrapper');
                const w = wrapper.offsetWidth;
                const h = wrapper.offsetHeight;
                this.canvas.width = w; this.canvas.height = h;
                this.bgCanvas.width = w; this.bgCanvas.height = h;
                // ËÆ°ÁÆóÂü∫Âú∞ÈÄªËæëÂÆΩÂ∫¶ (ÁôæÂàÜÊØî) = (Â§ñËæπË∑ù + ÂÆûÈôÖÂÆΩÂ∫¶) / ÁîªÂ∏ÉÂÆΩÂ∫¶
                const totalBasePx = CONSTANTS.BASE_OFFSET_PX + CONSTANTS.BASE_WIDTH_PX;
                this.baseWidthPct = (totalBasePx / w) * 100;
            }

            toggleDockItem(id) {
                if (this.state.selectedDockId === id) this.closePopover();
                else { this.state.selectedDockId = id; this.buildPopover(); this.updateDockVisuals(); }
            }
            closePopover() {
                this.state.selectedDockId = null;
                document.getElementById('popover-container').style.display = 'none';
                this.updateDockVisuals();
            }

            modWork(type, change) {
                const p = this.state.player;
                if (change > 0) {
                    if (p.idleWorkers > 0) { p.idleWorkers--; p.assignments[type]++; }
                    else this.showToast("Ê≤°ÊúâÁ©∫Èó≤ÊùëÊ∞ë");
                } else {
                    if (p.assignments[type] > 0) { p.assignments[type]--; p.idleWorkers++; }
                }
            }

            updateLogic() {
                if (this.gameOver) return;
                this.state.tick++;
                if (this.state.tick % 10 === 0) {
                    this.gatherResources(this.state.player);
                    this.gatherResources(this.state.enemy);
                    this.runAI();
                }
                this.processBuildingQueues(this.state.player); this.processBuildingQueues(this.state.enemy);
                this.processConstructions(this.state.player); this.processConstructions(this.state.enemy);

                this.state.turretShots = [];
                this.processBaseDefense(this.state.player);
                this.processBaseDefense(this.state.enemy);

                this.updateUnits();
                this.updateUI();
            }

            gatherResources(f) {
                const GATHER_RATE = 0.6;
                f.food += f.assignments.food * GATHER_RATE;
                f.wood += f.assignments.wood * GATHER_RATE;
                f.gold += f.assignments.gold * GATHER_RATE;
                f.stone += f.assignments.stone * GATHER_RATE;
            }

            processBuildingQueues(f) {
                f.buildingInstances.forEach(b => {
                    if (b.queue.length > 0) {
                        const item = b.queue[0];
                        // Ê≠£Â∏∏ÂÄíËÆ°Êó∂
                        if (item.ticksLeft > 0) {
                            item.ticksLeft--;
                        }

                        // ÂÄíËÆ°Êó∂ÁªìÊùüÔºåÂáÜÂ§áÁªìÁÆó
                        if (item.ticksLeft <= 0) {
                            // Â¶ÇÊûúÊòØÁßëÊäÄÔºåÁõ¥Êé•ÂÆåÊàê
                            if (CONSTANTS.TECHS[item.type]) {
                                this.completeTech(f, item.type);
                                b.queue.shift();
                                this.refreshPopoverIfSelected(b.id);
                            }
                            // Â¶ÇÊûúÊòØÂçï‰ΩçÔºåÈúÄË¶ÅÊ£ÄÊü•Âá∫Âè£ÈòªÂ°ûÊÉÖÂÜµÂíå‰∫∫Âè£ÊÉÖÂÜµ
                            else {
                                const currentPop = f.workers + f.armyCount;
                                // ‰øÆÂ§çÔºöÊ£ÄÊü•‰∫∫Âè£Êó∂ÔºåÂøÖÈ°ªÂêåÊó∂Ê£ÄÊü• 200 ÁöÑÁ°¨‰∏äÈôêÂíå f.popCap (ÊàøÂ±ãÊèê‰æõÁöÑ‰∏äÈôê)
                                const isFullPop = (f.name !== 'enemy' && (currentPop >= MAX_TOTAL_POP || currentPop >= f.popCap));

                                // Ê£ÄÊü•Âá∫Âè£ÈòªÂ°û
                                // Áé©ÂÆ∂Âá∫ÁîüÁÇπÂú®Âü∫Âú∞‰∏≠ÂøÉ(offset + width/2)ÔºåÂç≥ÈÄªËæëÂÆΩÂ∫¶ÁöÑ‰∏≠Èó¥
                                const spawnPos = f.name === 'player' ? (this.baseWidthPct / 2) : (100 - this.baseWidthPct / 2);
                                // Ê£ÄÊü•ÈôÑËøëÊòØÂê¶ÊúâÂçï‰Ωç (ËåÉÂõ¥ËÆæ‰∏∫2%)
                                const isBlocked = this.state.units.some(u => Math.abs(u.pos - spawnPos) < 2);

                                if (isFullPop || isBlocked) {
                                    // Êó†Ê≥ïÂÆåÊàêÔºåËøõÂ∫¶Êù°Âç°Âú®0.1 (Âç≥99.9%)
                                    item.ticksLeft = 0.1;
                                    // ËøôÈáå UI ‰ºöÊòæÁ§∫ "ÈòªÂ°û" Êàñ "‰∫∫Âè£Êª°"
                                } else {
                                    // ÊàêÂäü‰∫ßÂá∫
                                    this.spawnUnit(f, item.type, spawnPos);
                                    b.queue.shift();
                                    this.refreshPopoverIfSelected(b.id);
                                }
                            }
                        }
                    }
                });
            }

            refreshPopoverIfSelected(bid) {
                if (this.state.selectedDockId === bid) this.buildPopover();
                else if (!this.state.selectedDockId) this.closePopover();
            }

            completeTech(f, techId) {
                const tech = CONSTANTS.TECHS[techId];
                if (techId === 'turret_tech') {
                    f.hasTurret = true;
                    if (f.name === 'player') this.showToast("ÁÇÆÂè∞Á≥ªÁªüÂçáÁ∫ßÂÆåÊàê!", "#8b5cf6");
                } else {
                    const typeKey = tech.type;
                    if (f.techLevels[typeKey] !== undefined) {
                        f.techLevels[typeKey] = tech.level;
                        if (f.name === 'player') this.showToast(`${tech.label} Á†îÂèëÂÆåÊàê!`, "#8b5cf6");
                        this.applyTechUpgrade(f, typeKey);
                    }
                }
            }

            applyTechUpgrade(f, typeKey) {
                this.state.units.filter(u => u.owner === f.name && CONSTANTS.UNITS[u.type].type === 'mil').forEach(u => {
                    const uData = CONSTANTS.UNITS[u.type];
                    if (typeKey === 'atk_m' && (!uData.attackType || uData.attackType === 'melee')) u.dmg += 1;
                    if (typeKey === 'atk_r' && uData.attackType === 'ranged') u.dmg += 1;
                    if (typeKey === 'def_m') u.def_m += 1;
                    if (typeKey === 'def_r') u.def_r += 1;
                });
            }

            processBaseDefense(f) {
                if (!f.hasTurret) return;
                if (f.turretCooldown > 0) { f.turretCooldown--; return; }
                const RANGE = BASE_RANGE * 2;
                const DAMAGE = CONSTANTS.UNITS.clubman.dmg * 1.5;
                const COOLDOWN = Math.floor(10 / 1.25);
                // ÁÇÆÂè∞ÊîªÂáªÈÄªËæëÔºö‰ªéÂü∫Âú∞ÁöÑÂ§ñÂ¢ôÁÆóËµ∑ÔºåËÄå‰∏çÊòØ‰∏≠ÂøÉ
                const baseWallPos = f.name === 'player' ? this.baseWidthPct : (100 - this.baseWidthPct);
                const enemies = this.state.units.filter(u => u.owner !== f.name);
                const targets = enemies.filter(e => Math.abs(e.pos - baseWallPos) <= RANGE);

                if (targets.length > 0) {
                    f.turretCooldown = COOLDOWN;
                    const shotCount = Math.min(targets.length, 3);
                    for (let i = 0; i < shotCount; i++) {
                        const target = targets[Math.floor(Math.random() * targets.length)];
                        let actualDmg = Math.max(1, DAMAGE - target.def_r);
                        target.hp -= actualDmg;
                        this.spawnFloater(target.pos, `-${actualDmg.toFixed(1)}`, '#f0f');
                        // ÁâπÊïàËµ∑ÂßãÁÇπÔºöÂü∫Âú∞‰∏≠Èó¥‰∏äÊñπ
                        const visualStart = f.name === 'player' ? (this.baseWidthPct / 2) : (100 - this.baseWidthPct / 2);
                        this.state.turretShots.push({ start: visualStart, end: target.pos, color: f.name === 'player' ? '#60a5fa' : '#f87171' });
                    }
                }
            }

            processConstructions(f) {
                const activeConstructions = [];
                let shouldRebuildDock = false;
                f.constructions.forEach(task => {
                    task.ticksLeft--;
                    if (task.ticksLeft <= 0) {
                        if (task.type === 'house' || task.type === 'towncenter') f.popCap = Math.min(f.popCap + (CONSTANTS.BUILDINGS[task.type].pop || 0), MAX_TOTAL_POP);
                        f.buildingInstances.push({ id: `${f.name}-b-${this.buildingIdCounter++}`, type: task.type, queue: [] });
                        if (f.name === 'player') { this.showToast(`${CONSTANTS.BUILDINGS[task.type].label} Âª∫ÈÄ†ÂÆåÊàê`, '#22c55e'); shouldRebuildDock = true; }
                    } else { activeConstructions.push(task); }
                });
                f.constructions = activeConstructions;
                if (shouldRebuildDock) { this.closePopover(); this.renderDock(); }
            }

            spawnUnit(f, type, spawnPos) {
                if (CONSTANTS.UNITS[type].type === 'eco') { f.workers++; f.idleWorkers++; }
                else {
                    f.armyCount++;
                    const u = new Entity(type, f.name, this.entityIdCounter++, spawnPos);
                    if (CONSTANTS.UNITS[type].type === 'mil') {
                        const uData = CONSTANTS.UNITS[type];
                        if (uData.attackType === 'ranged') u.dmg += f.techLevels.atk_r;
                        else u.dmg += f.techLevels.atk_m;
                        u.def_m += f.techLevels.def_m;
                        u.def_r += f.techLevels.def_r;
                    }
                    this.state.units.push(u);
                }
            }

            playerQueueUnit(bid, type) {
                const f = this.state.player; const b = f.buildingInstances.find(i => i.id === bid);
                if (!b) return;
                const unitData = CONSTANTS.UNITS[type];
                if (b.queue.length >= MAX_QUEUE_SIZE) { this.showToast("ÈòüÂàóÂ∑≤Êª°"); return; }
                // ÂÖÅËÆ∏Êª°‰∫∫Âè£Êó∂ÊéíÈòüÔºå‰ΩÜÂú®Áîü‰∫ßÁªìÊùüÊó∂Âç°‰Ωè
                const costF = unitData.cost.food || 0; const costW = unitData.cost.wood || 0; const costG = unitData.cost.gold || 0;
                if (f.food < costF || f.wood < costW || f.gold < costG) { this.showToast("ËµÑÊ∫ê‰∏çË∂≥"); return; }
                f.food -= costF; f.wood -= costW; f.gold -= costG;
                b.queue.push({ type: type, ticksLeft: unitData.time, totalTicks: unitData.time });
                this.refreshPopoverState();
            }

            playerQueueTech(bid, techId) {
                const f = this.state.player; const b = f.buildingInstances.find(i => i.id === bid);
                if (!b) return;
                const tech = CONSTANTS.TECHS[techId];
                if (b.queue.length > 0) { this.showToast("ÈòüÂàó‰∏ç‰∏∫Á©∫"); return; }
                if (f.food < tech.cost.food || f.wood < tech.cost.wood || f.gold < tech.cost.gold || f.stone < tech.cost.stone) { this.showToast("ËµÑÊ∫ê‰∏çË∂≥"); return; }

                f.food -= (tech.cost.food || 0);
                f.wood -= (tech.cost.wood || 0);
                f.gold -= (tech.cost.gold || 0);
                f.stone -= (tech.cost.stone || 0);

                b.queue.push({ type: techId, ticksLeft: tech.time, totalTicks: tech.time });
                this.showToast("Á†îÂèë: " + tech.label, "#8b5cf6");
                this.closePopover();
            }

            playerBuildStructure(type) {
                const f = this.state.player; const d = CONSTANTS.BUILDINGS[type];
                if (type === 'house' && f.popCap >= MAX_TOTAL_POP) { this.showToast("‰∫∫Âè£Â∑≤Ëææ‰∏äÈôê"); return; }
                const sCost = d.cost.stone || 0;
                if (f.food < d.cost.food || f.wood < d.cost.wood || f.stone < sCost) { this.showToast("ËµÑÊ∫ê‰∏çË∂≥"); return; }
                f.food -= d.cost.food; f.wood -= d.cost.wood; f.stone -= sCost;
                f.constructions.push({ id: this.constructionIdCounter++, type: type, ticksLeft: d.time, totalTicks: d.time });
                this.showToast(`ÂºÄÂßãÂª∫ÈÄ† ${d.label}`);
                this.closePopover(); this.renderDock();
            }

            setPlayerStance(s) {
                this.state.playerStance = s;
                ['defend', 'hold', 'attack'].forEach(k => {
                    const b = document.getElementById(`btn-stance-${k}`);
                    b.className = `tactic-btn ${k === s ? 'active' : ''}`;
                });
            }

            // ... AI Logic kept same mostly, logic is abstract from positioning ...
            runAI() {
                const ai = this.state.enemy;
                ai.assignments = { food: 0, wood: 0, gold: 0, stone: 0 };
                ai.idleWorkers = 0;
                const resources = [
                    { type: 'food', amount: ai.food },
                    { type: 'wood', amount: ai.wood },
                    { type: 'gold', amount: ai.gold }
                ];
                resources.sort((a, b) => a.amount - b.amount);
                ai.assignments[resources[0].type] = ai.workers;

                const eUnits = this.state.units.filter(u => u.owner === 'enemy');
                const myArchers = eUnits.filter(u => u.type === 'longbowman').length;
                const pUnits = this.state.units.filter(u => u.owner === 'player');
                const enemyArchers = pUnits.filter(u => u.type === 'longbowman').length;

                const pCountHalf = pUnits.filter(u => u.pos > 50).length;
                const eCountHalf = eUnits.filter(u => u.pos > 50).length;

                let playerFront = 0;
                if (pUnits.length > 0) playerFront = Math.max(...pUnits.map(u => u.pos));
                let enemyFront = 100;
                if (eUnits.length > 0) enemyFront = Math.min(...eUnits.map(u => u.pos));

                const distance = enemyFront - playerFront;
                const battleLine = (playerFront + enemyFront) / 2;

                let savingForTech = false;
                const blacksmith = ai.buildingInstances.find(b => b.type === 'blacksmith');
                const isPushing = battleLine < 40;

                if ((ai.armyCount > 5 || isPushing) && blacksmith && blacksmith.queue.length === 0) {
                    const levels = ai.techLevels;
                    let targetTech = null;
                    const checkTech = (type, lvl) => levels[type] < lvl ? `tech_${type}_${levels[type] + 1}` : null;

                    if (myArchers > 2 && levels.atk_r < levels.atk_m) targetTech = checkTech('atk_r', 3);
                    else if (enemyArchers > 3 && levels.def_r < levels.def_m) targetTech = checkTech('def_r', 3);

                    if (!targetTech) {
                        // ... simplify for brevity, same logic as before ...
                        if (levels.atk_m < 1) targetTech = 'tech_atk_m_1';
                        else if (levels.def_m < 1) targetTech = 'tech_def_m_1';
                        else if (levels.atk_r < 1) targetTech = 'tech_atk_r_1';
                        else if (levels.def_r < 1) targetTech = 'tech_def_r_1';
                        // ... (levels 2 and 3 checks omitted for space, assume existing logic)
                    }

                    if (targetTech) {
                        const techData = CONSTANTS.TECHS[targetTech];
                        if (techData) { // Check if tech exists (levels logic might overshoot)
                            const costF = techData.cost.food || 0;
                            const costW = techData.cost.wood || 0;
                            const costG = techData.cost.gold || 0;
                            const costS = techData.cost.stone || 0;

                            if (ai.food >= costF && ai.wood >= costW && ai.gold >= costG && ai.stone >= costS) {
                                ai.food -= costF; ai.wood -= costW; ai.gold -= costG; ai.stone -= costS;
                                blacksmith.queue.push({ type: targetTech, ticksLeft: techData.time, totalTicks: techData.time });
                            } else {
                                savingForTech = true;
                            }
                        }
                    }
                }

                if (!savingForTech) {
                    let pendingWorkers = 0;
                    ai.buildingInstances.forEach(b => { b.queue.forEach(q => { if (q.type === 'worker') pendingWorkers++; }); });

                    const clubmanCount = eUnits.filter(u => u.type === 'clubman').length;
                    const samuraiCount = eUnits.filter(u => u.type === 'samurai').length;

                    const buildings = [...ai.buildingInstances].sort((a, b) => a.type === 'towncenter' ? -1 : 1);
                    buildings.forEach(b => {
                        if (b.queue.length < 5) {
                            if (b.type === 'towncenter') {
                                if (ai.workers + pendingWorkers < 60) {
                                    this.aiQueue(ai, b, 'worker'); pendingWorkers++;
                                }
                            } else if (b.type === 'barracks') {
                                const samCost = CONSTANTS.UNITS.samurai.cost;
                                if (clubmanCount < 3) {
                                    this.aiQueue(ai, b, 'clubman');
                                } else if (ai.gold >= samCost.gold && samuraiCount < clubmanCount * 2) {
                                    this.aiQueue(ai, b, 'samurai');
                                } else {
                                    this.aiQueue(ai, b, 'clubman');
                                }
                            } else if (b.type === 'archery_range') {
                                const bowCost = CONSTANTS.UNITS.longbowman.cost;
                                if (ai.wood >= bowCost.wood + 50 && ai.food >= bowCost.food) {
                                    this.aiQueue(ai, b, 'longbowman');
                                }
                            }
                        }
                    });
                }
                // ... structure building logic kept same ...
                const countType = (t) => {
                    const built = ai.buildingInstances.filter(b => b.type === t).length;
                    const constructing = ai.constructions.filter(c => c.type === t).length;
                    return built + constructing;
                };
                let structureToBuild = null;
                const numBarracks = countType('barracks');
                const numArchery = countType('archery_range');
                const numBlacksmith = countType('blacksmith');

                if (numBarracks < 1) structureToBuild = 'barracks';
                else if (numArchery < 1) structureToBuild = 'archery_range';
                else if (numBlacksmith < 1) structureToBuild = 'blacksmith';
                else if (numBarracks < 4 || ai.wood > 600) structureToBuild = 'barracks';

                if (structureToBuild) {
                    const d = CONSTANTS.BUILDINGS[structureToBuild];
                    const cF = d.cost.food || 0; const cW = d.cost.wood || 0; const cS = d.cost.stone || 0;
                    if (ai.food >= cF && ai.wood >= cW && ai.stone >= cS) {
                        this.aiBuild(ai, structureToBuild);
                    }
                }

                let newStance = 'attack';
                if (eCountHalf > pCountHalf) { newStance = 'attack'; } else {
                    if (distance > 30) newStance = 'attack';
                    else { if (battleLine > 65) newStance = 'defend'; else newStance = 'attack'; }
                }
                if (this.state.enemyStance !== newStance) this.state.enemyStance = newStance;
            }

            aiBuild(f, t) {
                const d = CONSTANTS.BUILDINGS[t]; const s = d.cost.stone || 0;
                if (f.food >= d.cost.food && f.wood >= d.cost.wood && f.stone >= s) {
                    f.food -= d.cost.food; f.wood -= d.cost.wood; f.stone -= s;
                    f.constructions.push({ id: Math.random(), type: t, ticksLeft: d.time, totalTicks: d.time });
                }
            }
            aiQueue(f, b, u) {
                const d = CONSTANTS.UNITS[u];
                if (f.food >= d.cost.food && f.wood >= d.cost.wood && f.gold >= (d.cost.gold || 0)) {
                    f.food -= d.cost.food; f.wood -= d.cost.wood; f.gold -= (d.cost.gold || 0);
                    b.queue.push({ type: u, ticksLeft: d.time, totalTicks: d.time });
                }
            }

            updateUI() {
                const p = this.state.player; const e = this.state.enemy;
                document.getElementById('p-base-hp').style.width = Math.max(0, (p.baseHp / CONSTANTS.BASE_HP * 100)) + '%';
                document.getElementById('e-base-hp').style.width = Math.max(0, (e.baseHp / CONSTANTS.BASE_HP * 100)) + '%';

                if (p.hasTurret) document.getElementById('p-base').classList.add('has-turret');
                if (e.hasTurret) document.getElementById('e-base').classList.add('has-turret');

                const toRoman = (n) => n === 0 ? '0' : (n === 1 ? 'I' : (n === 2 ? 'II' : 'III'));
                document.getElementById('p-tech-atk-m').innerText = `‚öîÔ∏è ${toRoman(p.techLevels.atk_m)}`;
                document.getElementById('p-tech-def-m').innerText = `üõ°Ô∏è ${toRoman(p.techLevels.def_m)}`;
                document.getElementById('p-tech-atk-r').innerText = `üèπ ${toRoman(p.techLevels.atk_r)}`;
                document.getElementById('p-tech-def-r').innerText = `üéØ ${toRoman(p.techLevels.def_r)}`;

                document.getElementById('e-tech-atk-m').innerText = `‚öîÔ∏è ${toRoman(e.techLevels.atk_m)}`;
                document.getElementById('e-tech-def-m').innerText = `üõ°Ô∏è ${toRoman(e.techLevels.def_m)}`;
                document.getElementById('e-tech-atk-r').innerText = `üèπ ${toRoman(e.techLevels.atk_r)}`;
                document.getElementById('e-tech-def-r').innerText = `üéØ ${toRoman(e.techLevels.def_r)}`;

                const currentPop = p.workers + p.armyCount;
                const popEl = document.getElementById('disp-pop');
                popEl.innerText = `${currentPop}/${p.popCap}`;

                // ÊÅ¢Â§ç‰∫∫Âè£È¢úËâ≤ÁöÑÈÄªËæë
                if (currentPop >= p.popCap) {
                    popEl.style.color = '#ef4444';
                    popEl.classList.add('warning'); // Ê∑ªÂä†Èó™ÁÉÅÂä®Áîª
                } else {
                    popEl.classList.remove('warning');
                    if (currentPop >= p.popCap * 0.8) {
                        popEl.style.color = '#eab308';
                    } else {
                        popEl.style.color = '#e5e5e5';
                    }
                }

                const idleEl = document.getElementById('disp-idle'); idleEl.innerText = p.idleWorkers;
                if (p.idleWorkers > 0) idleEl.classList.add('warning'); else idleEl.classList.remove('warning');

                ['food', 'wood', 'gold', 'stone'].forEach(r => {
                    document.getElementById(`res-stock-${r}`).innerText = Math.floor(p[r]);
                    document.getElementById(`res-workers-${r}`).innerText = p.assignments[r];
                    const btnAdd = document.getElementById(`add-${r}`);
                    const btnSub = document.getElementById(`sub-${r}`);
                    if (p.idleWorkers > 0) btnAdd.classList.remove('disabled'); else btnAdd.classList.add('disabled');
                    if (p.assignments[r] > 0) btnSub.classList.remove('disabled'); else btnSub.classList.add('disabled');
                });

                this.updateDockProgress();
                if (this.state.selectedDockId) this.refreshPopoverState();
            }

            renderDock() {
                const dock = document.getElementById('dock'); dock.innerHTML = ''; const p = this.state.player;
                const houses = p.buildingInstances.filter(b => b.type === 'house');
                const builtBuildings = p.buildingInstances.filter(b => b.type !== 'house').map(b => ({ ...b, isConstruction: false }));
                const underConstruction = p.constructions.map(c => ({ ...c, isConstruction: true }));
                const mixedList = [...builtBuildings, ...underConstruction];

                // ÊÅ¢Â§çÂõ∫ÂÆöÁöÑÊéíÂ∫èÈÄªËæë
                mixedList.sort((a, b) => {
                    const order = { towncenter: 1, barracks: 2, archery_range: 3, blacksmith: 4 };
                    return (order[a.type] || 99) - (order[b.type] || 99);
                });

                mixedList.forEach(item => {
                    if (item.isConstruction) {
                        const icon = this.createDockIcon(`const-${item.id}`, CONSTANTS.BUILDINGS[item.type].icon, true);
                        dock.appendChild(icon);
                    } else {
                        const icon = this.createDockIcon(item.id, CONSTANTS.BUILDINGS[item.type].icon, false);
                        icon.onclick = () => this.toggleDockItem(item.id);
                        dock.appendChild(icon);
                    }
                });
                if (houses.length > 0) { const icon = this.createDockIcon('group-house', CONSTANTS.BUILDINGS['house'].icon, false); icon.onclick = () => this.toggleDockItem('group-house'); icon.querySelector('.icon-badge').style.display = 'flex'; icon.querySelector('.icon-badge').classList.add('house-badge'); icon.querySelector('.icon-badge').innerText = houses.length; dock.appendChild(icon); }
                const hammer = this.createDockIcon('dock-build_menu', 'üî®', false); hammer.classList.add('build-icon'); hammer.onclick = () => this.toggleDockItem('build_menu'); dock.appendChild(hammer);
                this.updateDockVisuals();
            }

            createDockIcon(id, emoji, isConstructing) {
                const icon = document.createElement('div'); icon.className = `dock-icon ${isConstructing ? 'constructing' : ''}`;
                icon.id = `dock-elem-${id}`; icon.dataset.refId = id; icon.innerHTML = emoji;
                if (isConstructing) { const overlay = document.createElement('div'); overlay.className = 'const-overlay'; icon.appendChild(overlay); }
                const barBg = document.createElement('div'); barBg.className = 'icon-progress-bg'; const barFill = document.createElement('div'); barFill.className = 'icon-progress-fill'; barBg.appendChild(barFill); icon.appendChild(barBg);
                const badge = document.createElement('div'); badge.className = 'icon-badge'; badge.style.display = 'none'; icon.appendChild(badge);
                return icon;
            }

            updateDockProgress() {
                const p = this.state.player;
                p.buildingInstances.forEach(b => {
                    if (b.type === 'house') return;
                    const el = document.getElementById(`dock-elem-${b.id}`);
                    if (el) {
                        const barBg = el.querySelector('.icon-progress-bg'); const bar = el.querySelector('.icon-progress-fill'); const badge = el.querySelector('.icon-badge');
                        if (b.queue.length > 0) {
                            const t = b.queue[0];
                            // Â¶ÇÊûúËøõÂ∫¶Âç°Âú® 99.9% (0.1 ticks)ÔºåÊòæÁ§∫ÁâπÊÆäÁöÑÂ†µÂ°ûÁä∂ÊÄÅ
                            if (t.ticksLeft <= 0.2 && t.ticksLeft > 0) {
                                bar.style.width = '100%';
                                bar.style.backgroundColor = '#ef4444'; // Á∫¢Ëâ≤Ë°®Á§∫Â†µÂ°û
                            } else {
                                bar.style.width = (100 - (t.ticksLeft / t.totalTicks * 100)) + '%';
                                bar.style.backgroundColor = CONSTANTS.TECHS[t.type] ? '#22c55e' : '#3b82f6';
                            }
                            badge.style.display = 'flex'; badge.innerText = b.queue.length; barBg.style.display = 'block';
                            if (CONSTANTS.TECHS[t.type]) el.classList.add('researching'); else el.classList.remove('researching');
                        } else {
                            bar.style.width = '0%'; badge.style.display = 'none'; barBg.style.display = 'none'; el.classList.remove('researching');
                        }
                    }
                });
                const houseCount = p.buildingInstances.filter(b => b.type === 'house').length;
                const hIcon = document.getElementById('dock-elem-group-house');
                if (hIcon) { hIcon.querySelector('.icon-badge').innerText = houseCount; if (hIcon.querySelector('.icon-progress-bg')) hIcon.querySelector('.icon-progress-bg').style.display = 'none'; }
                p.constructions.forEach(task => {
                    const el = document.getElementById(`dock-elem-const-${task.id}`);
                    if (el) {
                        const bar = el.querySelector('.icon-progress-fill'); const overlay = el.querySelector('.const-overlay');
                        const pct = Math.floor(100 - (task.ticksLeft / task.totalTicks * 100)); bar.style.width = pct + '%'; overlay.innerText = pct + '%'; el.querySelector('.icon-progress-bg').style.display = 'block';
                    }
                });
            }

            updateDockVisuals() {
                const dock = document.getElementById('dock');
                Array.from(dock.children).forEach(el => {
                    const logicalId = el.id === 'dock-elem-dock-build_menu' ? 'build_menu' : el.dataset.refId;
                    if (this.state.selectedDockId === logicalId) el.classList.add('active'); else el.classList.remove('active');
                });
            }

            buildPopover() {
                const container = document.getElementById('popover-container');
                const id = this.state.selectedDockId;
                if (!id) { container.style.display = 'none'; return; }
                container.innerHTML = ''; container.style.display = 'flex';
                const domId = id === 'build_menu' ? 'dock-elem-dock-build_menu' : `dock-elem-${id}`;
                const icon = document.getElementById(domId);
                if (icon) { const rect = icon.getBoundingClientRect(); container.style.left = (rect.left + rect.width / 2) + 'px'; }

                const p = this.state.player;
                if (id === 'build_menu') {
                    container.innerHTML = `<div class="popover-title">Âª∫ÈÄ†</div>`;
                    ['house', 'barracks', 'archery_range', 'blacksmith', 'towncenter'].forEach(t => {
                        const d = CONSTANTS.BUILDINGS[t];
                        const btn = document.createElement('div'); btn.className = 'menu-btn build-action-btn'; btn.dataset.type = t;
                        btn.onclick = () => this.playerBuildStructure(t);
                        let cost = []; if (d.cost.food) cost.push(`${d.cost.food}ËÇâ`); if (d.cost.wood) cost.push(`${d.cost.wood}Êú®`); if (d.cost.stone) cost.push(`${d.cost.stone}Áü≥`);
                        btn.innerHTML = `<span class="btn-icon">${d.icon}</span><div class="btn-info"><span>${d.label}</span><span class="btn-cost">${cost.join(' ')}</span></div>`;
                        container.appendChild(btn);
                    });
                } else if (id === 'group-house') {
                    container.innerHTML = `<div class="popover-title">ÊàøÂ±ã</div><div class="p-2 text-sm text-gray-300 text-center">ÊàøÂ±ãÁî®‰∫éÂ¢ûÂä†‰∫∫Âè£</div>`;
                } else {
                    const b = p.buildingInstances.find(x => x.id === id);
                    if (b) {
                        const buildingLabel = CONSTANTS.BUILDINGS[b.type].label;
                        container.innerHTML = `<div class="popover-title">${buildingLabel}</div>`;
                        const statusDiv = document.createElement('div');
                        statusDiv.id = 'popover-prog-status';
                        statusDiv.className = 'text-xs text-blue-400 text-center mb-2 font-bold';
                        statusDiv.style.display = 'none';
                        container.appendChild(statusDiv);

                        if (b.type === 'towncenter' || b.type === 'barracks' || b.type === 'archery_range') {
                            let unitTypes = [];
                            if (b.type === 'towncenter') unitTypes = ['worker'];
                            else if (b.type === 'barracks') unitTypes = ['clubman', 'samurai'];
                            else if (b.type === 'archery_range') unitTypes = ['longbowman'];
                            unitTypes.forEach(uType => {
                                const u = CONSTANTS.UNITS[uType];
                                const btn = document.createElement('div'); btn.className = 'menu-btn produce-action-btn'; btn.dataset.type = uType;
                                btn.onclick = () => this.playerQueueUnit(id, uType);
                                let cost = []; if (u.cost.food) cost.push(`${u.cost.food}ËÇâ`); if (u.cost.wood) cost.push(`${u.cost.wood}Êú®`); if (u.cost.gold) cost.push(`${u.cost.gold}Èáë`);
                                btn.innerHTML = `<span class="btn-icon">${uType === 'worker' ? 'üë∑' : (uType === 'longbowman' ? 'üèπ' : '‚öîÔ∏è')}</span><div class="btn-info"><span>ËÆ≠ÁªÉ${u.label}</span><span class="btn-cost">${cost.join(' ')}</span></div>`;
                                container.appendChild(btn);
                            });
                        }

                        if (b.type === 'towncenter') {
                            const isQueuingTurret = p.buildingInstances.some(bi => bi.queue.some(q => q.type === 'turret_tech'));
                            if (!p.hasTurret && !isQueuingTurret) {
                                const tech = CONSTANTS.TECHS.turret_tech;
                                const techBtn = document.createElement('div'); techBtn.className = 'menu-btn tech-btn'; techBtn.dataset.tech = 'turret_tech';
                                techBtn.onclick = () => this.playerQueueTech(id, 'turret_tech');
                                let tCost = []; if (tech.cost.gold) tCost.push(`${tech.cost.gold}Èáë`); if (tech.cost.stone) tCost.push(`${tech.cost.stone}Áü≥`);
                                techBtn.innerHTML = `<span class="btn-icon">${tech.icon}</span><div class="btn-info"><span>Á†îÂèë${tech.label}</span><span class="btn-cost">${tCost.join(' ')}</span></div>`;
                                container.appendChild(techBtn);
                            }
                        }

                        if (b.type === 'blacksmith') {
                            const ongoingTechs = new Set();
                            p.buildingInstances.forEach(bi => { bi.queue.forEach(q => { if (q.type.startsWith('tech_')) ongoingTechs.add(q.type); }); });
                            const techLevels = p.techLevels;
                            const techTypes = ['atk_m', 'def_m', 'atk_r', 'def_r'];
                            let anyUpgradeAvailable = false;
                            const isThisBuildingBusy = b.queue.length > 0;
                            if (!isThisBuildingBusy) {
                                techTypes.forEach(type => {
                                    const currentLvl = techLevels[type];
                                    const nextLvl = currentLvl + 1;
                                    const techId = `tech_${type}_${nextLvl}`;
                                    if (currentLvl < 3 && !ongoingTechs.has(techId)) {
                                        anyUpgradeAvailable = true;
                                        const tech = CONSTANTS.TECHS[techId];
                                        const techBtn = document.createElement('div'); techBtn.className = 'menu-btn tech-btn'; techBtn.dataset.tech = techId;
                                        techBtn.onclick = () => this.playerQueueTech(id, techId);
                                        let tCost = [];
                                        if (tech.cost.wood) tCost.push(`${tech.cost.wood}Êú®`);
                                        if (tech.cost.food) tCost.push(`${tech.cost.food}ËÇâ`);
                                        if (tech.cost.gold) tCost.push(`${tech.cost.gold}Èáë`);
                                        techBtn.innerHTML = `<span class="btn-icon">${tech.icon}</span><div class="btn-info"><span>${tech.label}</span><span class="btn-cost">${tCost.join(' ')}</span></div>`;
                                        container.appendChild(techBtn);
                                    }
                                });
                            }
                            if (!anyUpgradeAvailable && !isThisBuildingBusy) { container.innerHTML += `<div class="text-xs text-gray-400 text-center mt-2">ÊâÄÊúâÂèØÁî®ÁßëÊäÄÂùáÂú®Á†îÂèë‰∏≠ÊàñÂ∑≤Êª°Á∫ß</div>`; }
                        }
                        const q = document.createElement('div'); q.id = 'popover-queue-info'; q.className = 'text-xs text-gray-400 text-center mt-1'; container.appendChild(q);
                    }
                }
                this.refreshPopoverState();
            }

            refreshPopoverState() {
                const id = this.state.selectedDockId; if (!id || id === 'group-house') return;
                const p = this.state.player;
                if (id === 'build_menu') {
                    document.querySelectorAll('.build-action-btn').forEach(btn => {
                        const t = btn.dataset.type; const d = CONSTANTS.BUILDINGS[t];
                        const s = d.cost.stone || 0; const f = d.cost.food || 0; const w = d.cost.wood || 0;
                        if (p.food >= f && p.wood >= w && p.stone >= s) btn.removeAttribute('disabled'); else btn.setAttribute('disabled', 'true');
                    });
                } else {
                    const b = p.buildingInstances.find(x => x.id === id);
                    if (!b) { this.closePopover(); return; }

                    const statusEl = document.getElementById('popover-prog-status');
                    if (statusEl) {
                        if (b.queue.length > 0) {
                            const currentItem = b.queue[0];
                            let itemLabel = '';
                            let action = 'Áîü‰∫ß';
                            if (CONSTANTS.UNITS[currentItem.type]) itemLabel = CONSTANTS.UNITS[currentItem.type].label;
                            else if (CONSTANTS.TECHS[currentItem.type]) { itemLabel = CONSTANTS.TECHS[currentItem.type].label; action = 'Á†îÂèë'; }

                            // Â¶ÇÊûú ticksLeft <= 0.2ÔºåËØ¥ÊòéÂç°‰Ωè‰∫Ü
                            if (currentItem.ticksLeft <= 0.2) {
                                statusEl.innerText = `‚ö†Ô∏è Áîü‰∫ßÈòªÂ°û (‰∫∫Âè£Êª°ÊàñÂá∫Âè£Â†µÂ°û)`;
                                statusEl.style.color = '#ef4444';
                            } else {
                                const progress = Math.floor(100 - (currentItem.ticksLeft / currentItem.totalTicks * 100));
                                statusEl.innerText = `Ê≠£Âú®${action}: ${itemLabel} (${progress}%)`;
                                statusEl.style.color = action === 'Á†îÂèë' ? '#22c55e' : '#60a5fa';
                            }
                            statusEl.style.display = 'block';
                        } else {
                            statusEl.style.display = 'none';
                        }
                    }

                    document.querySelectorAll('.produce-action-btn').forEach(btn => {
                        const t = btn.dataset.type; const u = CONSTANTS.UNITS[t];
                        const f = u.cost.food || 0; const w = u.cost.wood || 0; const g = u.cost.gold || 0;
                        if (p.food >= f && p.wood >= w && p.gold >= g) btn.removeAttribute('disabled'); else btn.setAttribute('disabled', 'true');
                    });
                    document.querySelectorAll('.tech-btn').forEach(btn => {
                        const tId = btn.dataset.tech; const t = CONSTANTS.TECHS[tId];
                        const f = t.cost.food || 0; const w = t.cost.wood || 0; const g = t.cost.gold || 0; const s = t.cost.stone || 0;
                        if (p.food >= f && p.wood >= w && p.gold >= g && p.stone >= s) btn.removeAttribute('disabled'); else btn.setAttribute('disabled', 'true');
                    });
                    const qInfo = document.getElementById('popover-queue-info'); if (qInfo) qInfo.innerText = `ÈòüÂàó: ${b.queue.length}`;
                }
            }

            updateUnits() {
                // Ëé∑ÂèñÊâÄÊúâÂçï‰Ωç
                let p = this.state.units.filter(u => u.owner === 'player');
                let e = this.state.units.filter(u => u.owner === 'enemy').sort((a, b) => a.pos - b.pos);

                // Áé©ÂÆ∂ÊéíÂ∫èÔºöÊ†πÊçÆÂßøÊÄÅÂÜ≥ÂÆö‰ªéÂ∑¶Âà∞Âè≥ËøòÊòØ‰ªéÂè≥Âà∞Â∑¶Â§ÑÁêÜÁ¢∞Êíû
                // ËøõÊîªÊó∂ÔºöÈù†ÂâçÁöÑÔºàÂè≥ËæπÔºâÂÖàÁßªÂä®
                if (this.state.playerStance === 'attack') p.sort((a, b) => b.pos - a.pos);
                else p.sort((a, b) => a.pos - b.pos);

                // ÂáÜÂ§áÁ¢∞ÊíûÂàóË°®
                const pForCollision = [...p].sort((a, b) => b.pos - a.pos);
                const eForCollision = [...e];

                // Â§ÑÁêÜÁé©ÂÆ∂Âçï‰Ωç
                p.forEach((u, i) => {
                    this.processCombat(u, e, 1);
                    // ÂèãÂÜõÁ¢∞Êíû (Âêålane)
                    const friendsInLane = p.filter(f => f.lane === u.lane);
                    const laneIndex = friendsInLane.findIndex(f => f.id === u.id);
                    this.processMovement(u, friendsInLane, eForCollision, laneIndex, 1);
                });

                // Â§ÑÁêÜÁîµËÑëÂçï‰Ωç
                e.forEach((u, i) => {
                    this.processCombat(u, p, -1);
                    const friendsInLane = e.filter(f => f.lane === u.lane);
                    const laneIndex = friendsInLane.findIndex(f => f.id === u.id);
                    this.processMovement(u, friendsInLane, pForCollision, laneIndex, -1);
                });

                // Ê∏ÖÁêÜÊ≠ª‰∫°Âçï‰Ωç
                const dead = this.state.units.filter(u => u.hp <= 0);
                dead.forEach(u => this.handleUnitDeath(u));
                this.state.units = this.state.units.filter(u => u.hp > 0);

                if (this.state.player.baseHp <= 0) this.endGame('DEFEAT', '‰Ω†ÁöÑÂ∏ùÂõΩÈô∑ËêΩ‰∫Ü„ÄÇ');
                if (this.state.enemy.baseHp <= 0) this.endGame('VICTORY', '‰Ω†ÂæÅÊúç‰∫ÜÈáéËõÆ‰∫∫ÔºÅ');
            }

            handleUnitDeath(u) {
                const f = u.owner === 'player' ? this.state.player : this.state.enemy;
                if (CONSTANTS.UNITS[u.type].type === 'eco') {
                    if (f.workers > 0) {
                        f.workers--;
                        if (f.idleWorkers > 0) f.idleWorkers--;
                        else {
                            for (const r of ['stone', 'gold', 'wood', 'food']) if (f.assignments[r] > 0) { f.assignments[r]--; break; }
                        }
                    }
                } else { f.armyCount = Math.max(0, f.armyCount - 1); }
            }

            processCombat(u, ens, dir) {
                if (u.attackAnimTimer > 0) u.attackAnimTimer--; if (u.attackCooldown > 0) u.attackCooldown--;

                // Logic Fix: Don't target enemies behind the wall if you are a melee unit
                const uData = CONSTANTS.UNITS[u.type];
                const isMelee = !uData.attackType || uData.attackType === 'melee';
                const wallPos = dir === 1 ? (100 - this.baseWidthPct) : this.baseWidthPct;

                let v = ens.filter(e => {
                    // Range check
                    if (Math.abs(u.pos - e.pos) > u.range) return false;
                    // Wall Line-of-Sight check for Melee
                    if (isMelee) {
                        // If I am outside (attacker), and he is inside (target)
                        if (dir === 1) { // Player attacking right
                            if (u.pos < wallPos && e.pos > wallPos) return false;
                        } else { // Enemy attacking left
                            if (u.pos > wallPos && e.pos < wallPos) return false;
                        }
                    }
                    return true;
                });

                let t = null;
                if (v.length > 0) {
                    v.sort((a, b) => Math.abs(u.pos - a.pos) - Math.abs(u.pos - b.pos));
                    t = v[0];
                } else {
                    // ÊîªÂáªÂü∫Âú∞Â¢ôÂ£ÅÂà§ÂÆö
                    // Áé©ÂÆ∂ÂêëÂè≥Êâì(1): ÁõÆÊ†áÂ¢ôÊòØ 100 - baseWidthPct
                    // ÁîµËÑëÂêëÂ∑¶Êâì(-1): ÁõÆÊ†áÂ¢ôÊòØ baseWidthPct
                    const targetBaseWall = dir === 1 ? (100 - this.baseWidthPct) : this.baseWidthPct;
                    if (Math.abs(u.pos - targetBaseWall) <= u.range) t = "base";
                }

                if (t) {
                    u.state = 'attack'; u.targetId = (t === "base") ? "base" : t.id;
                    if (u.attackCooldown <= 0) {
                        u.attackCooldown = CONSTANTS.UNITS[u.type].cooldown || 10;
                        u.attackAnimTimer = 3; const dmg = u.dmg;
                        if (t === "base") {
                            const baseDef = 2;
                            const actualDmg = Math.max(1, dmg - baseDef);
                            if (u.owner === 'player') this.state.enemy.baseHp -= actualDmg;
                            else this.state.player.baseHp -= actualDmg;
                            // È£òÂ≠ó‰ΩçÁΩÆ
                            const floatPos = dir === 1 ? (100 - this.baseWidthPct) : this.baseWidthPct;
                            this.spawnFloater(floatPos, `-${actualDmg}`, '#f00');
                        } else {
                            const uData = CONSTANTS.UNITS[u.type];
                            const atkType = uData.attackType || 'melee';
                            let defVal = (atkType === 'ranged') ? t.def_r : t.def_m;
                            let actualDmg = Math.max(1, dmg - defVal);
                            t.hp -= actualDmg;
                            this.spawnFloater(t.pos, `-${actualDmg}`, '#fff');
                        }
                    }
                } else { u.state = 'move'; }
            }

            processMovement(u, friends, enemies, i, dir) {
                // ËøúÁ®ãÂçï‰ΩçÂ¶ÇÊûúÊ≠£Âú®ÊîªÂáª‰∏îË¶ÅÊ±ÇÂÅúÊ≠¢ÔºåÂàôÂÅúÊ≠¢
                if (u.stopOnAttack && u.state === 'attack') return;

                // Ê†∏ÂøÉ‰øÆÊîπÔºöÂü∫Âú∞Áâ©ÁêÜÂÆû‰ΩìÂà§ÂÆö
                // Â¶ÇÊûúÂçï‰ΩçÂàöÂá∫Áîü (!isDeployed)ÔºåÂÆÉÂèØ‰ª•Á©øËøáÂü∫Âú∞Â¢ôÂ£ÅÂêëÂ§ñËµ∞
                // ‰∏ÄÊó¶Âçï‰ΩçÂÆåÂÖ®Ëµ∞Âá∫Âü∫Âú∞ËåÉÂõ¥ÔºåÊ†áËÆ∞‰∏∫ isDeployed = trueÔºå‰πãÂêéÂ∞ÜÂíåÂü∫Âú∞Â¢ôÂ£ÅÁ¢∞Êíû

                const myBaseWall = u.owner === 'player' ? this.baseWidthPct : (100 - this.baseWidthPct);

                // Ê£ÄÊµãÊòØÂê¶Â∑≤Âá∫Âüé (Áé©ÂÆ∂>Â¢ô, ÁîµËÑë<Â¢ô)
                if (!u.isDeployed) {
                    if (u.owner === 'player' && u.pos > myBaseWall + 1) u.isDeployed = true;
                    if (u.owner === 'enemy' && u.pos < myBaseWall - 1) u.isDeployed = true;
                }

                let d = u.pos;
                const s = u.owner === 'player' ? this.state.playerStance : this.state.enemyStance;
                let speed = u.speed;
                if (dir === -1) speed = -speed;

                // È¢ÑÂà§‰∏ã‰∏ÄÊ≠•‰ΩçÁΩÆ
                let nextD = d;

                if (s === 'attack') {
                    nextD += speed;
                    // ÂèãÂÜõÁ¢∞Êíû
                    if (i > 0) {
                        const l = friends[i - 1].pos - (dir * u.width);
                        if (dir === 1 ? nextD > l : nextD < l) nextD = l;
                    }
                    // ÊïåÂÜõÁ¢∞Êíû
                    if (enemies.length > 0) {
                        const l = enemies[0].pos - (dir * u.width);
                        if (dir === 1 ? nextD > l : nextD < l) nextD = l;
                    }
                    // Âú∞ÂõæËæπÁïå (Âü∫Âú∞Â¢ôÂ£ÅÊòØÊïå‰∫∫ÁöÑËæπÁïå)
                    // Ê†∏ÂøÉ‰øÆÂ§çÔºöËøôÈáå‰∏çÊòØ elseÔºåÊòØÂº∫Âà∂Á∫¶ÊùüÔºÅ
                    const enemyWallPos = dir === 1 ? (100 - this.baseWidthPct) : this.baseWidthPct;

                    if (dir === 1) {
                        if (nextD > enemyWallPos - 2) nextD = enemyWallPos - 2;
                    } else {
                        if (nextD < enemyWallPos + 2) nextD = enemyWallPos + 2;
                    }
                } else {
                    // Èò≤ÂÆà/ÂæÖÂëΩ
                    if (s === 'defend') {
                        nextD -= speed;
                    }

                    if (dir === 1) { // Áé©ÂÆ∂
                        let limit = 0;
                        // Â¶ÇÊûúÂ∑≤Âá∫ÂüéÔºåÂè™ËÉΩÈÄÄÂà∞Â¢ôËæπ
                        if (u.isDeployed) limit = this.baseWidthPct + 1;

                        if (i > 0) {
                            // Â¶ÇÊûúÂâçÈù¢ÊúâÈòüÂèãÔºå‰∏çËÉΩÁ©øËøáÈòüÂèã
                            limit = Math.max(limit, friends[i - 1].pos + u.width);
                        }
                        if (nextD < limit) nextD = limit;
                    } else { // ÁîµËÑë
                        let limit = 100;
                        if (u.isDeployed) limit = (100 - this.baseWidthPct) - 1;

                        if (i < friends.length - 1) {
                            limit = Math.min(limit, friends[i + 1].pos - u.width);
                        }
                        if (nextD > limit) nextD = limit;
                    }
                }
                u.pos = nextD;
            }

            spawnFloater(x, t, c) { const el = document.createElement('div'); el.className = 'floater'; const r = document.getElementById('game-wrapper').getBoundingClientRect(); el.style.left = (x / 100 * r.width) + 'px'; el.style.top = (r.height / 2 - 20) + 'px'; el.style.color = c; el.innerText = t; document.getElementById('game-wrapper').appendChild(el); setTimeout(() => el.remove(), 1000); }
            showToast(msg, c = '#ef4444') { const el = document.createElement('div'); el.className = 'toast text-white px-4 py-2 rounded shadow-lg font-bold'; el.style.background = c; el.innerText = msg; document.getElementById('toast-container').appendChild(el); setTimeout(() => el.remove(), 2000); }

            loop() { if (!this.gameOver) { this.draw(); requestAnimationFrame(() => this.loop()); } }

            draw() {
                const w = this.canvas.width; const h = this.canvas.height;

                this.ctx.clearRect(0, 0, w, h);
                this.bgCtx.clearRect(0, 0, w, h);

                // ÁîªËΩ®ÈÅìÁ∫ø
                this.bgCtx.strokeStyle = '#555';
                this.bgCtx.beginPath(); this.bgCtx.moveTo(0, h / 2 - 20); this.bgCtx.lineTo(w, h / 2 - 20); this.bgCtx.stroke();
                this.bgCtx.beginPath(); this.bgCtx.moveTo(0, h / 2 + 20); this.bgCtx.lineTo(w, h / 2 + 20); this.bgCtx.stroke();

                // ÁîªÁÇÆÂè∞ÊøÄÂÖâ
                this.state.turretShots.forEach(shot => {
                    this.ctx.strokeStyle = shot.color; this.ctx.lineWidth = 3; this.ctx.beginPath();
                    this.ctx.moveTo((shot.start / 100) * w, h / 2 - 20); // ‰ªéÈ´òÂ§ÑÊâì‰∏ãÊù•
                    this.ctx.lineTo((shot.end / 100) * w, h / 2); this.ctx.stroke();
                    this.ctx.fillStyle = 'white'; this.ctx.beginPath(); this.ctx.arc((shot.end / 100) * w, h / 2, 5, 0, Math.PI * 2); this.ctx.fill();
                });

                this.state.units.forEach(u => {
                    const x = (u.pos / 100) * w;
                    const laneY = u.lane === 1 ? (h / 2 - 20) : (h / 2 + 20);

                    this.ctx.fillStyle = u.owner === 'player' ? '#3b82f6' : '#ef4444';

                    if (u.type === 'samurai') {
                        this.ctx.fillRect(x - 8, laneY - 20, 16, 20);
                    } else if (u.type === 'clubman') {
                        this.ctx.beginPath(); this.ctx.arc(x, laneY - 8, 8, 0, Math.PI * 2); this.ctx.fill();
                    } else if (u.type === 'longbowman') {
                        this.ctx.fillStyle = u.owner === 'player' ? '#8b5cf6' : '#a855f7';
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, laneY - 20);
                        this.ctx.lineTo(x - 6, laneY);
                        this.ctx.lineTo(x + 6, laneY);
                        this.ctx.fill();
                    } else {
                        this.ctx.fillRect(x - 5, laneY - 15, 10, 15);
                    }

                    this.ctx.fillStyle = '#ccc';
                    if (u.type === 'clubman') {
                        this.ctx.fillRect(u.owner === 'player' ? x + 2 : x - 12, laneY - 10, 10, 2);
                    } else if (u.type !== 'longbowman') {
                        this.ctx.fillRect(u.owner === 'player' ? x + 5 : x - 5, laneY - 15, 8, 2);
                    }

                    if (u.attackAnimTimer > 0) {
                        this.ctx.strokeStyle = '#ffff00'; this.ctx.lineWidth = 2; this.ctx.beginPath();
                        this.ctx.moveTo(u.owner === 'player' ? x + 5 : x - 5, laneY - 15 + (Math.random() * 6 - 3));
                        let tx = u.owner === 'player' ? x + 30 : x - 30; let ty = laneY - 10;
                        if (u.targetId === "base") {
                            // ÊîªÂáªÂü∫Âú∞Â¢ôÂ£ÅÔºåËÄå‰∏çÊòØÊ∑±Â§Ñ
                            tx = u.owner === 'player' ? (100 - this.baseWidthPct) / 100 * w : (this.baseWidthPct / 100) * w;
                        } else {
                            const t = this.state.units.find(k => k.id === u.targetId);
                            if (t) {
                                tx = (t.pos / 100) * w;
                                const targetLaneY = t.lane === 1 ? (h / 2 - 20) : (h / 2 + 20);
                                ty = targetLaneY - 10;
                            }
                        }
                        this.ctx.lineTo(tx, ty); this.ctx.stroke();
                    }
                    const hp = u.hp / u.maxHp; this.ctx.fillStyle = 'red'; this.ctx.fillRect(x - 8, laneY - 25, 16, 3); this.ctx.fillStyle = '#0f0'; this.ctx.fillRect(x - 8, laneY - 25, 16 * hp, 3);
                });
            }
            endGame(r, m) { this.gameOver = true; clearInterval(this.logicInterval); document.getElementById('game-over').style.display = 'flex'; document.getElementById('end-title').innerText = r; document.getElementById('end-title').className = r === 'VICTORY' ? 'text-5xl font-bold mb-4 text-green-500' : 'text-5xl font-bold mb-4 text-red-500'; document.getElementById('end-reason').innerText = m; }
        }
        const game = new Game();

        window.show_me_the_money = function () {
            if (game && game.state && game.state.player) {
                game.state.player.food = 9999; game.state.player.wood = 9999; game.state.player.gold = 9999; game.state.player.stone = 9999;
                game.updateUI();
                console.log("Resources granted: 9999 [Food, Wood, Gold, Stone]");
            }
        }
    </script>
</body>

</html>
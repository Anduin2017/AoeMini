<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æœ´ç´ å¸å›½ - Minimalist Empire</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ä¿æŒåŸæœ‰çš„ CSS ä¸å˜ */
        body {
            background-color: #111;
            color: #e5e5e5;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            user-select: none;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #game-wrapper {
            position: relative;
            flex: 1;
            overflow: hidden;
            background: #262626;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* --- å›¾å±‚ç®¡ç† --- */

        /* 1. èƒŒæ™¯ç”»å¸ƒ (ç”»çº¿) - æœ€åº•å±‚ */
        #bgCanvas {
            z-index: 5;
        }

        /* 2. åŸºåœ° - ä¸­é—´å±‚ (ç›–ä½çº¿) */
        .base {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 64px;
            height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.8rem;
            z-index: 10;
            pointer-events: none;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* 3. æ¸¸æˆä¸»ç”»å¸ƒ (å£«å…µ/ç‰¹æ•ˆ) - åœ¨åŸºåœ°ä¸Šé¢ */
        #gameCanvas {
            z-index: 15;
        }

        /* 4. é£˜å­—ç‰¹æ•ˆ - æœ€é«˜å±‚ */
        .floater {
            position: absolute;
            color: white;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 1px 1px 2px black;
            z-index: 100;
        }

        .base-player {
            left: 0;
            background: #3b82f6;
            border-right: 4px solid #1d4ed8;
        }

        .base-enemy {
            right: 0;
            background: #ef4444;
            border-left: 4px solid #b91c1c;
        }

        .turret-addon {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 20px;
            background-color: #4b5563;
            border: 2px solid #9ca3af;
            border-radius: 4px 4px 0 0;
            display: none;
        }

        .turret-addon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            background-color: #000;
            border-radius: 50%;
        }

        .has-turret .turret-addon {
            display: block;
        }

        .hp-bar-bg {
            width: 90%;
            height: 4px;
            background: rgba(0, 0, 0, 0.5);
            margin-top: 2px;
        }

        .hp-bar-fill {
            height: 100%;
            background: #22c55e;
            width: 100%;
            transition: width 0.2s;
        }

        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px 20px;
            pointer-events: none;
            z-index: 20;
        }

        .top-group {
            display: flex;
            flex-direction: column;
        }

        .top-group.right {
            align-items: flex-end;
        }

        .top-item {
            font-weight: bold;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px black;
            line-height: 1.2;
        }

        .tech-status {
            font-family: monospace;
            font-size: 0.8rem;
            font-weight: bold;
            margin-top: 2px;
            text-shadow: 1px 1px 1px black;
            opacity: 0.9;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px 8px;
        }

        .text-blue {
            color: #60a5fa;
        }

        .text-red {
            color: #f87171;
        }

        .text-blue-light {
            color: #93c5fd;
        }

        .text-red-light {
            color: #fca5a5;
        }

        .tactics-bar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 30;
            pointer-events: auto;
        }

        .tactic-btn {
            background: rgba(30, 30, 30, 0.6);
            border: 1px solid #555;
            color: #ccc;
            padding: 6px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
            font-size: 0.85rem;
        }

        .tactic-btn:hover {
            background: #444;
            color: white;
        }

        .tactic-btn.active {
            background: #2563eb;
            border-color: #60a5fa;
            color: white;
            box-shadow: 0 0 8px #2563eb;
        }

        .resource-widget {
            position: absolute;
            bottom: 100px;
            left: 20px;
            width: 280px;
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            z-index: 40;
            backdrop-filter: blur(8px);
        }

        @media (max-height: 500px) {
            .resource-widget {
                bottom: 90px;
                left: 10px;
                transform: scale(0.9);
                transform-origin: bottom left;
            }
        }

        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            margin-bottom: 8px;
            border-bottom: 1px solid #4b5563;
            font-size: 1rem;
        }

        .status-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .icon-house {
            color: #f59e0b;
        }

        .pop-text {
            font-weight: bold;
            font-family: monospace;
            transition: color 0.2s;
        }

        .icon-sleep {
            color: #9ca3af;
        }

        .idle-text {
            color: #9ca3af;
            font-weight: bold;
            font-family: monospace;
        }

        .idle-text.warning {
            color: #ef4444;
            animation: pulse 1s infinite;
        }

        .res-grid {
            display: grid;
            grid-template-columns: 24px 1fr 24px 50px 24px;
            gap: 4px;
            align-items: center;
            font-size: 0.9rem;
        }

        .res-icon {
            text-align: center;
            font-size: 1rem;
        }

        .res-val {
            font-family: monospace;
            text-align: right;
            padding-right: 10px;
            color: #e5e5e5;
            font-weight: bold;
        }

        .worker-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            height: 24px;
        }

        .res-w-icon {
            color: #9ca3af;
            font-size: 0.7rem;
        }

        .res-w-val {
            color: #60a5fa;
            font-family: monospace;
            font-weight: bold;
        }

        .tiny-btn {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #374151;
            border: 1px solid #4b5563;
            border-radius: 4px;
            cursor: pointer;
            color: #ccc;
            font-size: 0.9rem;
            line-height: 0;
            transition: background 0.1s;
        }

        .tiny-btn:hover {
            background: #4b5563;
            color: white;
        }

        .tiny-btn.disabled {
            opacity: 0.2;
            cursor: default;
            pointer-events: none;
        }

        .dock-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 8px;
            border-radius: 16px;
            display: flex;
            gap: 12px;
            z-index: 50;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            max-width: 95vw;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .dock-container::-webkit-scrollbar {
            display: none;
        }

        .dock-icon {
            width: 56px;
            height: 56px;
            background: #2d2d2d;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            cursor: pointer;
            position: relative;
            transition: transform 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: 1px solid #444;
            flex-shrink: 0;
        }

        .dock-icon:hover {
            transform: translateY(-5px) scale(1.1);
            background: #3d3d3d;
            z-index: 60;
        }

        .dock-icon.active {
            background: #333;
            box-shadow: 0 0 0 2px #3b82f6;
            transform: translateY(-5px);
        }

        .dock-icon.build-icon {
            background: #eab308;
            color: #000;
            border-color: #ca8a04;
        }

        .dock-icon.build-icon:hover {
            background: #facc15;
        }

        .dock-icon.constructing {
            opacity: 0.7;
            border-style: dashed;
            background: #1f2937;
        }

        .dock-icon.constructing .const-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            font-size: 12px;
            color: #eab308;
            font-weight: bold;
        }

        .icon-progress-bg {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            overflow: hidden;
            display: none;
        }

        .icon-progress-fill {
            height: 100%;
            width: 0%;
            background: #3b82f6;
            transition: width linear 0.1s;
        }

        .constructing .icon-progress-fill {
            background: #eab308;
        }

        .dock-icon.researching .icon-progress-fill {
            background: #22c55e;
        }

        .icon-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ef4444;
            color: white;
            font-size: 10px;
            font-weight: bold;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 2px black;
        }

        .icon-badge.house-badge {
            background: #eab308;
            color: #000;
        }

        .popover-menu {
            position: absolute;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid #4b5563;
            border-radius: 8px;
            padding: 10px;
            min-width: 180px;
            display: none;
            flex-direction: column;
            gap: 8px;
            z-index: 60;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(12px);
        }

        .popover-menu::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
            width: 12px;
            height: 12px;
            background: rgba(31, 41, 55, 0.95);
            border-right: 1px solid #4b5563;
            border-bottom: 1px solid #4b5563;
        }

        .popover-title {
            font-size: 0.8rem;
            color: #9ca3af;
            text-transform: uppercase;
            border-bottom: 1px solid #4b5563;
            padding-bottom: 4px;
            margin-bottom: 4px;
            text-align: center;
        }

        .menu-btn {
            background: #374151;
            border: 1px solid #4b5563;
            color: white;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            transition: all 0.1s;
        }

        .menu-btn:hover:not(:disabled) {
            background: #4b5563;
        }

        .menu-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .btn-icon {
            font-size: 1.4rem;
        }

        .btn-info {
            display: flex;
            flex-direction: column;
            line-height: 1.2;
            text-align: left;
        }

        .btn-cost {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        .menu-btn.tech-btn {
            border-color: #8b5cf6;
            background: rgba(139, 92, 246, 0.1);
        }

        .menu-btn.tech-btn:hover:not(:disabled) {
            background: rgba(139, 92, 246, 0.3);
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            display: none;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-30px);
                opacity: 0;
            }
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        #unit-tooltip {
            position: absolute;
            background: rgba(17, 24, 39, 0.95);
            border: 1px solid #4b5563;
            padding: 8px 12px;
            border-radius: 6px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            color: white;
            font-size: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            min-width: 140px;
        }

        .tt-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }

        .tt-header {
            font-weight: bold;
            color: #60a5fa;
            border-bottom: 1px solid #4b5563;
            margin-bottom: 4px;
            padding-bottom: 2px;
            text-align: center;
        }

        .tt-enemy .tt-header {
            color: #f87171;
        }

        .tt-sub {
            color: #9ca3af;
            font-size: 11px;
        }

        .val-bonus {
            color: #22c55e;
            margin-left: 2px;
        }
    </style>
</head>

<body>

    <div id="toast-container" class="fixed top-4 left-1/2 transform -translate-x-1/2 z-50"></div>

    <div class="top-bar">
        <div class="top-group">
            <div class="top-item text-blue">ç©å®¶</div>
            <div class="tech-status text-blue-light">
                <span id="p-tech-atk-m" title="è¿‘æˆ˜æ”»å‡»">âš”ï¸ 0</span>
                <span id="p-tech-def-m" title="è¿‘æˆ˜é˜²å¾¡">ğŸ›¡ï¸ 0</span>
                <span id="p-tech-atk-r" title="è¿œç¨‹æ”»å‡»">ğŸ¹ 0</span>
                <span id="p-tech-def-r" title="è¿œç¨‹é˜²å¾¡">ğŸ¯ 0</span>
            </div>
        </div>

        <div class="top-group right">
            <div class="top-item text-red">ç”µè„‘</div>
            <div class="tech-status text-red-light">
                <span id="e-tech-atk-m" title="è¿‘æˆ˜æ”»å‡»">âš”ï¸ 0</span>
                <span id="e-tech-def-m" title="è¿‘æˆ˜é˜²å¾¡">ğŸ›¡ï¸ 0</span>
                <span id="e-tech-atk-r" title="è¿œç¨‹æ”»å‡»">ğŸ¹ 0</span>
                <span id="e-tech-def-r" title="è¿œç¨‹é˜²å¾¡">ğŸ¯ 0</span>
            </div>
        </div>
    </div>

    <div id="game-wrapper">
        <div class="tactics-bar">
            <button id="btn-stance-defend" class="tactic-btn" onclick="game.setPlayerStance('defend')">ğŸ›¡ï¸ é˜²å®ˆ</button>
            <button id="btn-stance-hold" class="tactic-btn" onclick="game.setPlayerStance('hold')">âœ‹ å¾…å‘½</button>
            <button id="btn-stance-attack" class="tactic-btn active" onclick="game.setPlayerStance('attack')">âš”ï¸
                è¿›æ”»</button>
        </div>
        <canvas id="bgCanvas"></canvas>
        <canvas id="gameCanvas"></canvas>

        <div id="unit-tooltip"></div>

        <div id="p-base" class="base base-player">
            <div class="turret-addon"></div>
            <div>åŸºåœ°</div>
            <div class="hp-bar-bg">
                <div id="p-base-hp" class="hp-bar-fill"></div>
            </div>
        </div>
        <div id="e-base" class="base base-enemy">
            <div class="turret-addon"></div>
            <div>ç”µè„‘</div>
            <div class="hp-bar-bg">
                <div id="e-base-hp" class="hp-bar-fill"></div>
            </div>
        </div>
    </div>

    <div id="ui-layer">
        <div class="resource-widget">
            <div class="status-header">
                <div class="status-group" title="äººå£">
                    <span class="icon-house">ğŸ </span> <span id="disp-pop" class="pop-text">0/200</span>
                </div>
                <div class="status-group" title="ç©ºé—²æ‘æ°‘">
                    <span class="icon-sleep">ğŸ’¤</span> <span id="disp-idle" class="idle-text">0</span>
                </div>
            </div>
            <div class="res-grid">
                <div class="res-icon">ğŸ¥©</div>
                <div class="res-val" id="res-stock-food">0</div>
                <div class="tiny-btn" id="sub-food" onclick="game.modWork('food',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">ğŸ‘¤</span><span class="res-w-val"
                        id="res-workers-food">0</span></div>
                <div class="tiny-btn" id="add-food" onclick="game.modWork('food',1)">+</div>

                <div class="res-icon">ğŸŒ²</div>
                <div class="res-val" id="res-stock-wood">0</div>
                <div class="tiny-btn" id="sub-wood" onclick="game.modWork('wood',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">ğŸ‘¤</span><span class="res-w-val"
                        id="res-workers-wood">0</span></div>
                <div class="tiny-btn" id="add-wood" onclick="game.modWork('wood',1)">+</div>

                <div class="res-icon">ğŸª™</div>
                <div class="res-val" id="res-stock-gold">0</div>
                <div class="tiny-btn" id="sub-gold" onclick="game.modWork('gold',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">ğŸ‘¤</span><span class="res-w-val"
                        id="res-workers-gold">0</span></div>
                <div class="tiny-btn" id="add-gold" onclick="game.modWork('gold',1)">+</div>

                <div class="res-icon">ğŸª¨</div>
                <div class="res-val" id="res-stock-stone">0</div>
                <div class="tiny-btn" id="sub-stone" onclick="game.modWork('stone',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">ğŸ‘¤</span><span class="res-w-val"
                        id="res-workers-stone">0</span></div>
                <div class="tiny-btn" id="add-stone" onclick="game.modWork('stone',1)">+</div>
            </div>
        </div>

        <div class="dock-container" id="dock">
            <div class="dock-icon build-icon" id="dock-build_menu" onclick="game.toggleDockItem('build_menu')">
                ğŸ”¨
            </div>
        </div>

        <div id="popover-container" class="popover-menu"></div>
    </div>

    <div id="game-over">
        <h1 id="end-title" class="text-5xl font-bold mb-4 text-white">GAME OVER</h1>
        <p id="end-reason" class="text-xl text-gray-300 mb-8">Reason</p>
        <button onclick="location.reload()"
            class="px-6 py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded">å†æ¥ä¸€å±€</button>
    </div>

    <script>
        const TICK_RATE = 100;
        const MAX_QUEUE_SIZE = 5;
        const MAX_TOTAL_POP = 200;
        const BASE_RANGE = 5;

        const CONSTANTS = {
            INITIAL_RES: { food: 200, wood: 200, gold: 100, stone: 0 },
            BASE_HP: 2000, INITIAL_POP_CAP: 10,
            MAP_WIDTH_PERCENT: 100,
            UNIT_SIZE_PERCENT: 0.8,
            UNITS: {
                worker: { cost: { food: 50, wood: 0 }, time: 200, hp: 10, dmg: 0, def_m: 0, def_r: 0, type: 'eco', label: 'æ‘æ°‘', lane: 0, stopOnAttack: false },
                clubman: { cost: { food: 60, wood: 20 }, time: 150, hp: 90, dmg: 8, def_m: 0, def_r: 0, speed: 1.25, type: 'mil', label: 'é•¿æªå…µ', range: BASE_RANGE, lane: 0, stopOnAttack: false, attackType: 'melee', cooldown: 19 },
                samurai: { cost: { food: 100, wood: 0, gold: 20 }, time: 150, hp: 140, dmg: 11, def_m: 2, def_r: 3, speed: 1.125, type: 'mil', label: 'æ­¦å£«', range: BASE_RANGE * 0.75, lane: 0, stopOnAttack: false, attackType: 'melee', cooldown: 14 },
                longbowman: { cost: { food: 40, wood: 50, gold: 0 }, time: 150, hp: 70, dmg: 6, def_m: 0, def_r: 0, speed: 1.125, type: 'mil', label: 'é•¿å¼“å…µ', range: BASE_RANGE * 3, lane: 1, widthScale: 0.5, stopOnAttack: true, attackType: 'ranged', cooldown: 16 }
            },
            BUILDINGS: {
                house: { cost: { food: 0, wood: 50, stone: 0 }, pop: 10, time: 150, label: 'æˆ¿å±‹', icon: 'ğŸ ' },
                barracks: { cost: { food: 0, wood: 150, stone: 0 }, time: 300, label: 'å…µè¥', icon: 'âš”ï¸' },
                archery_range: { cost: { food: 0, wood: 150, stone: 0 }, time: 300, label: 'é¶åœº', icon: 'ğŸ¹' },
                towncenter: { cost: { food: 0, wood: 400, stone: 350 }, pop: 10, time: 1200, label: 'åŸºåœ°', icon: 'ğŸ›ï¸' },
                blacksmith: { cost: { food: 0, wood: 150, stone: 0 }, time: 250, label: 'é“åŒ é“º', icon: 'âš’ï¸' }
            },
            TECHS: {
                turret_tech: { cost: { food: 0, wood: 0, gold: 100, stone: 170 }, time: 240, label: 'é˜²å¾¡ç‚®å°', icon: 'ğŸ¯', desc: 'åŸºåœ°è·å¾—å¼ºå¤§é˜²å¾¡åŠ›' },
                tech_atk_m_1: { cost: { food: 50, wood: 0, gold: 125, stone: 0 }, time: 600, label: 'è¿‘æˆ˜æ”»å‡» I', icon: 'âš”ï¸', level: 1, type: 'atk_m' },
                tech_atk_m_2: { cost: { food: 100, wood: 0, gold: 250, stone: 0 }, time: 600, label: 'è¿‘æˆ˜æ”»å‡» II', icon: 'âš”ï¸', level: 2, type: 'atk_m' },
                tech_atk_m_3: { cost: { food: 150, wood: 0, gold: 300, stone: 0 }, time: 600, label: 'è¿‘æˆ˜æ”»å‡» III', icon: 'âš”ï¸', level: 3, type: 'atk_m' },
                tech_def_m_1: { cost: { food: 50, wood: 0, gold: 125, stone: 0 }, time: 600, label: 'è¿‘æˆ˜é˜²å¾¡ I', icon: 'ğŸ›¡ï¸', level: 1, type: 'def_m' },
                tech_def_m_2: { cost: { food: 100, wood: 0, gold: 250, stone: 0 }, time: 600, label: 'è¿‘æˆ˜é˜²å¾¡ II', icon: 'ğŸ›¡ï¸', level: 2, type: 'def_m' },
                tech_def_m_3: { cost: { food: 150, wood: 0, gold: 300, stone: 0 }, time: 600, label: 'è¿‘æˆ˜é˜²å¾¡ III', icon: 'ğŸ›¡ï¸', level: 3, type: 'def_m' },
                tech_atk_r_1: { cost: { food: 0, wood: 50, gold: 125, stone: 0 }, time: 600, label: 'è¿œç¨‹æ”»å‡» I', icon: 'ğŸ¹', level: 1, type: 'atk_r' },
                tech_atk_r_2: { cost: { food: 0, wood: 100, gold: 250, stone: 0 }, time: 600, label: 'è¿œç¨‹æ”»å‡» II', icon: 'ğŸ¹', level: 2, type: 'atk_r' },
                tech_atk_r_3: { cost: { food: 0, wood: 150, gold: 300, stone: 0 }, time: 600, label: 'è¿œç¨‹æ”»å‡» III', icon: 'ğŸ¹', level: 3, type: 'atk_r' },
                tech_def_r_1: { cost: { food: 0, wood: 50, gold: 125, stone: 0 }, time: 600, label: 'è¿œç¨‹é˜²å¾¡ I', icon: 'ğŸ¯', level: 1, type: 'def_r' },
                tech_def_r_2: { cost: { food: 0, wood: 100, gold: 250, stone: 0 }, time: 600, label: 'è¿œç¨‹é˜²å¾¡ II', icon: 'ğŸ¯', level: 2, type: 'def_r' },
                tech_def_r_3: { cost: { food: 0, wood: 150, gold: 300, stone: 0 }, time: 600, label: 'è¿œç¨‹é˜²å¾¡ III', icon: 'ğŸ¯', level: 3, type: 'def_r' }
            }
        };

        class Entity {
            constructor(type, owner, id) {
                this.id = id; this.type = type; this.owner = owner;
                const uData = CONSTANTS.UNITS[type];
                this.maxHp = uData.hp;
                this.hp = this.maxHp;
                this.dmg = uData.dmg || 0;
                this.def_m = uData.def_m || 0;
                this.def_r = uData.def_r || 0;
                this.speed = (uData.speed || 0) / (1000 / TICK_RATE);
                this.pos = owner === 'player' ? 5 : 95; this.state = 'move';
                this.width = CONSTANTS.UNIT_SIZE_PERCENT * (uData.widthScale || 1);
                this.range = uData.range || BASE_RANGE;
                this.lane = uData.lane !== undefined ? uData.lane : 0;
                this.stopOnAttack = uData.stopOnAttack !== undefined ? uData.stopOnAttack : false;
                this.attackCooldown = Math.floor(Math.random() * 10); this.attackAnimTimer = 0;
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.bgCanvas = document.getElementById('bgCanvas');
                this.bgCtx = this.bgCanvas.getContext('2d');

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.lastTick = 0; this.entityIdCounter = 0; this.buildingIdCounter = 0; this.constructionIdCounter = 0; this.gameOver = false;

                this.state = {
                    tick: 0,
                    player: this.createFactionState('player'),
                    enemy: this.createFactionState('enemy'),
                    units: [],
                    playerStance: 'attack',
                    enemyStance: 'attack',
                    selectedDockId: null,
                    turretShots: []
                };

                window.addEventListener('click', (e) => {
                    if (!e.target.closest('.dock-icon') && !e.target.closest('.popover-menu')) this.closePopover();
                });

                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseleave', () => { document.getElementById('unit-tooltip').style.display = 'none'; });

                this.renderDock();
                this.logicInterval = setInterval(() => this.updateLogic(), TICK_RATE);
                setInterval(() => this.debugAI(), 3000);
                requestAnimationFrame(() => this.loop());
            }

            handleMouseMove(e) {
                if (this.gameOver) return;
                const rect = this.canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                const w = this.canvas.width;
                const h = this.canvas.height;

                let foundUnit = null;
                for (const u of this.state.units) {
                    const unitX = (u.pos / 100) * w;
                    const laneY = u.lane === 1 ? (h / 2 - 20) : (h / 2 + 20);

                    if (Math.abs(mx - unitX) < 15 && Math.abs(my - laneY) < 20) {
                        foundUnit = u;
                        break;
                    }
                }
                const tt = document.getElementById('unit-tooltip');

                if (foundUnit) {
                    const uData = CONSTANTS.UNITS[foundUnit.type];
                    const isPlayer = foundUnit.owner === 'player';
                    const colorClass = isPlayer ? '' : 'tt-enemy';
                    const baseDmg = uData.dmg;
                    const bonusDmg = foundUnit.dmg - baseDmg;

                    tt.className = colorClass;
                    tt.innerHTML = `
                        <div class="tt-header">${uData.label} (${isPlayer ? 'æˆ‘æ–¹' : 'æ•Œæ–¹'})</div>
                        <div class="tt-row"><span>â¤ï¸ ç”Ÿå‘½:</span> <span>${Math.ceil(foundUnit.hp)}/${foundUnit.maxHp}</span></div>
                        <div class="tt-row"><span>ğŸ—¡ï¸ åŸºç¡€æ”»å‡»:</span> <span>${baseDmg}</span></div>
                        <div class="tt-row"><span>ğŸ”¥ æ”»å‡»åŠ æˆ:</span> <span class="val-bonus">+${bonusDmg}</span></div>
                        <div class="tt-row"><span>ğŸ›¡ï¸ è¿‘æˆ˜é˜²å¾¡:</span> <span>${foundUnit.def_m}</span></div>
                        <div class="tt-row"><span>ğŸ¯ è¿œç¨‹é˜²å¾¡:</span> <span>${foundUnit.def_r}</span></div>
                    `;
                    tt.style.left = (e.clientX + 15) + 'px';
                    tt.style.top = (e.clientY + 15) + 'px';
                    tt.style.display = 'block';
                } else {
                    let foundBase = null;
                    const baseYTop = h / 2 - 40;
                    const baseYBottom = h / 2 + 40;

                    if (my >= baseYTop && my <= baseYBottom) {
                        if (mx >= 0 && mx <= 64) {
                            foundBase = this.state.player;
                        } else if (mx >= w - 64 && mx <= w) {
                            foundBase = this.state.enemy;
                        }
                    }

                    if (foundBase) {
                        const isPlayer = foundBase.name === 'player';
                        const colorClass = isPlayer ? '' : 'tt-enemy';
                        const turretDmg = foundBase.hasTurret ? (CONSTANTS.UNITS.clubman.dmg * 1.5) : 0;
                        tt.className = colorClass;
                        tt.innerHTML = `
                            <div class="tt-header">${isPlayer ? 'æˆ‘æ–¹' : 'æ•Œæ–¹'}åŸºåœ°</div>
                            <div class="tt-row"><span>â¤ï¸ ç”Ÿå‘½:</span> <span>${Math.ceil(foundBase.baseHp)}/${CONSTANTS.BASE_HP}</span></div>
                            <div class="tt-row"><span>ğŸ›¡ï¸ è¿‘æˆ˜é˜²å¾¡:</span> <span>2</span></div>
                            <div class="tt-row"><span>ğŸ¯ è¿œç¨‹é˜²å¾¡:</span> <span>2</span></div>
                            ${foundBase.hasTurret ? `<div class="tt-row"><span>âš”ï¸ ç‚®å°:</span> <span>${turretDmg}</span></div>` : ''}
                        `;
                        tt.style.left = (e.clientX + 15) + 'px';
                        tt.style.top = (e.clientY + 15) + 'px';
                        tt.style.display = 'block';
                    } else {
                        tt.style.display = 'none';
                    }
                }
            }

            debugAI() {
                if (this.gameOver) return;
                const ai = this.state.enemy;
                console.groupCollapsed(`ğŸ¤– AI çŠ¶æ€ç›‘æ§ (Tick: ${this.state.tick})`);
                console.log(`ğŸ’° èµ„æº: F${Math.floor(ai.food)} W${Math.floor(ai.wood)} G${Math.floor(ai.gold)} S${Math.floor(ai.stone)}`);
                console.groupEnd();
            }

            createFactionState(name) {
                const initialBuildings = [{ id: `${name}-b-${this.buildingIdCounter++}`, type: 'towncenter', queue: [] }];
                let initialWorkers = 6;
                if (name === 'enemy') initialWorkers = 7;
                return {
                    name: name,
                    food: CONSTANTS.INITIAL_RES.food, wood: CONSTANTS.INITIAL_RES.wood, gold: CONSTANTS.INITIAL_RES.gold, stone: CONSTANTS.INITIAL_RES.stone,
                    idleWorkers: 0, assignments: { food: initialWorkers, wood: 0, gold: 0, stone: 0 }, workers: initialWorkers,
                    popCap: CONSTANTS.INITIAL_POP_CAP, baseHp: CONSTANTS.BASE_HP,
                    buildingInstances: initialBuildings, constructions: [], armyCount: 0,
                    hasTurret: false, turretCooldown: 0,
                    techLevels: { atk_m: 0, def_m: 0, atk_r: 0, def_r: 0 }
                };
            }

            resizeCanvas() {
                const wrapper = document.getElementById('game-wrapper');
                const w = wrapper.offsetWidth;
                const h = wrapper.offsetHeight;
                this.canvas.width = w; this.canvas.height = h;
                this.bgCanvas.width = w; this.bgCanvas.height = h;
            }

            toggleDockItem(id) {
                if (this.state.selectedDockId === id) this.closePopover();
                else { this.state.selectedDockId = id; this.buildPopover(); this.updateDockVisuals(); }
            }
            closePopover() {
                this.state.selectedDockId = null;
                document.getElementById('popover-container').style.display = 'none';
                this.updateDockVisuals();
            }

            modWork(type, change) {
                const p = this.state.player;
                if (change > 0) {
                    if (p.idleWorkers > 0) { p.idleWorkers--; p.assignments[type]++; }
                    else this.showToast("æ²¡æœ‰ç©ºé—²æ‘æ°‘");
                } else {
                    if (p.assignments[type] > 0) { p.assignments[type]--; p.idleWorkers++; }
                }
            }

            updateLogic() {
                if (this.gameOver) return;
                this.state.tick++;
                if (this.state.tick % 10 === 0) {
                    this.gatherResources(this.state.player);
                    this.gatherResources(this.state.enemy);
                    this.runAI();
                }
                this.processBuildingQueues(this.state.player); this.processBuildingQueues(this.state.enemy);
                this.processConstructions(this.state.player); this.processConstructions(this.state.enemy);

                this.state.turretShots = [];
                this.processBaseDefense(this.state.player);
                this.processBaseDefense(this.state.enemy);

                this.updateUnits();
                this.updateUI();
            }

            gatherResources(f) {
                const GATHER_RATE = 0.6;
                f.food += f.assignments.food * GATHER_RATE;
                f.wood += f.assignments.wood * GATHER_RATE;
                f.gold += f.assignments.gold * GATHER_RATE;
                f.stone += f.assignments.stone * GATHER_RATE;
            }

            processBuildingQueues(f) {
                f.buildingInstances.forEach(b => {
                    if (b.queue.length > 0) {
                        b.queue[0].ticksLeft--;
                        if (b.queue[0].ticksLeft <= 0) {
                            const item = b.queue[0];
                            if (CONSTANTS.TECHS[item.type]) {
                                const tech = CONSTANTS.TECHS[item.type];
                                if (item.type === 'turret_tech') {
                                    f.hasTurret = true;
                                    if (f.name === 'player') this.showToast("ç‚®å°ç³»ç»Ÿå‡çº§å®Œæˆ!", "#8b5cf6");
                                }
                                else {
                                    const typeKey = tech.type;
                                    if (f.techLevels[typeKey] !== undefined) {
                                        f.techLevels[typeKey] = tech.level;
                                        if (f.name === 'player') this.showToast(`${tech.label} ç ”å‘å®Œæˆ!`, "#8b5cf6");

                                        this.state.units.filter(u => u.owner === f.name && CONSTANTS.UNITS[u.type].type === 'mil').forEach(u => {
                                            const uData = CONSTANTS.UNITS[u.type];
                                            if (typeKey === 'atk_m' && (!uData.attackType || uData.attackType === 'melee')) u.dmg += 1;
                                            if (typeKey === 'atk_r' && uData.attackType === 'ranged') u.dmg += 1;
                                            if (typeKey === 'def_m') u.def_m += 1;
                                            if (typeKey === 'def_r') u.def_r += 1;
                                        });
                                    }
                                }
                                if (this.state.selectedDockId === b.id) this.buildPopover();
                                else this.closePopover();
                            } else {
                                this.spawnUnit(f, item.type);
                            }
                            b.queue.shift();
                        }
                    }
                });
            }

            processBaseDefense(f) {
                if (!f.hasTurret) return;
                if (f.turretCooldown > 0) { f.turretCooldown--; return; }
                const RANGE = BASE_RANGE * 2;
                const DAMAGE = CONSTANTS.UNITS.clubman.dmg * 1.5;
                const COOLDOWN = Math.floor(10 / 1.25);
                const basePos = f.name === 'player' ? 0 : 100;
                const enemies = this.state.units.filter(u => u.owner !== f.name);
                const targets = enemies.filter(e => Math.abs(e.pos - basePos) <= RANGE);
                if (targets.length > 0) {
                    f.turretCooldown = COOLDOWN;
                    const shotCount = Math.min(targets.length, 3);
                    for (let i = 0; i < shotCount; i++) {
                        const target = targets[Math.floor(Math.random() * targets.length)];
                        let actualDmg = Math.max(1, DAMAGE - target.def_r);
                        target.hp -= actualDmg;
                        this.spawnFloater(target.pos, `-${actualDmg.toFixed(1)}`, '#f0f');
                        this.state.turretShots.push({ start: basePos, end: target.pos, color: f.name === 'player' ? '#60a5fa' : '#f87171' });
                    }
                }
            }

            processConstructions(f) {
                const activeConstructions = [];
                let shouldRebuildDock = false;
                f.constructions.forEach(task => {
                    task.ticksLeft--;
                    if (task.ticksLeft <= 0) {
                        if (task.type === 'house' || task.type === 'towncenter') f.popCap = Math.min(f.popCap + (CONSTANTS.BUILDINGS[task.type].pop || 0), MAX_TOTAL_POP);
                        f.buildingInstances.push({ id: `${f.name}-b-${this.buildingIdCounter++}`, type: task.type, queue: [] });
                        if (f.name === 'player') { this.showToast(`${CONSTANTS.BUILDINGS[task.type].label} å»ºé€ å®Œæˆ`, '#22c55e'); shouldRebuildDock = true; }
                    } else { activeConstructions.push(task); }
                });
                f.constructions = activeConstructions;
                if (shouldRebuildDock) { this.closePopover(); this.renderDock(); }
            }

            spawnUnit(f, type) {
                if (f.name !== 'enemy' && f.workers + f.armyCount >= MAX_TOTAL_POP) return;
                if (CONSTANTS.UNITS[type].type === 'eco') { f.workers++; f.idleWorkers++; }
                else {
                    f.armyCount++;
                    const u = new Entity(type, f.name, this.entityIdCounter++);
                    if (CONSTANTS.UNITS[type].type === 'mil') {
                        const uData = CONSTANTS.UNITS[type];
                        if (uData.attackType === 'ranged') u.dmg += f.techLevels.atk_r;
                        else u.dmg += f.techLevels.atk_m;
                        u.def_m += f.techLevels.def_m;
                        u.def_r += f.techLevels.def_r;
                    }
                    this.state.units.push(u);
                }
            }

            playerQueueUnit(bid, type) {
                const f = this.state.player; const b = f.buildingInstances.find(i => i.id === bid);
                if (!b) return;
                const unitData = CONSTANTS.UNITS[type];
                if (b.queue.length >= MAX_QUEUE_SIZE) { this.showToast("é˜Ÿåˆ—å·²æ»¡"); return; }
                let totalPop = f.workers + f.armyCount; f.buildingInstances.forEach(bb => totalPop += bb.queue.length);
                if (totalPop >= MAX_TOTAL_POP || totalPop >= f.popCap) { this.showToast("äººå£ä¸è¶³"); return; }
                const costF = unitData.cost.food || 0; const costW = unitData.cost.wood || 0; const costG = unitData.cost.gold || 0;
                if (f.food < costF || f.wood < costW || f.gold < costG) { this.showToast("èµ„æºä¸è¶³"); return; }
                f.food -= costF; f.wood -= costW; f.gold -= costG;
                b.queue.push({ type: type, ticksLeft: unitData.time, totalTicks: unitData.time });
                this.refreshPopoverState();
            }

            playerQueueTech(bid, techId) {
                const f = this.state.player; const b = f.buildingInstances.find(i => i.id === bid);
                if (!b) return;
                const tech = CONSTANTS.TECHS[techId];
                if (b.queue.length > 0) { this.showToast("é˜Ÿåˆ—ä¸ä¸ºç©º"); return; }
                if (f.food < tech.cost.food || f.wood < tech.cost.wood || f.gold < tech.cost.gold || f.stone < tech.cost.stone) { this.showToast("èµ„æºä¸è¶³"); return; }

                f.food -= (tech.cost.food || 0);
                f.wood -= (tech.cost.wood || 0);
                f.gold -= (tech.cost.gold || 0);
                f.stone -= (tech.cost.stone || 0);

                b.queue.push({ type: techId, ticksLeft: tech.time, totalTicks: tech.time });
                this.showToast("ç ”å‘: " + tech.label, "#8b5cf6");
                this.closePopover();
            }

            playerBuildStructure(type) {
                const f = this.state.player; const d = CONSTANTS.BUILDINGS[type];
                if (type === 'house' && f.popCap >= MAX_TOTAL_POP) { this.showToast("äººå£å·²è¾¾ä¸Šé™"); return; }
                const sCost = d.cost.stone || 0;
                if (f.food < d.cost.food || f.wood < d.cost.wood || f.stone < sCost) { this.showToast("èµ„æºä¸è¶³"); return; }
                f.food -= d.cost.food; f.wood -= d.cost.wood; f.stone -= sCost;
                f.constructions.push({ id: this.constructionIdCounter++, type: type, ticksLeft: d.time, totalTicks: d.time });
                this.showToast(`å¼€å§‹å»ºé€  ${d.label}`);
                this.closePopover(); this.renderDock();
            }

            setPlayerStance(s) {
                this.state.playerStance = s;
                ['defend', 'hold', 'attack'].forEach(k => {
                    const b = document.getElementById(`btn-stance-${k}`);
                    b.className = `tactic-btn ${k === s ? 'active' : ''}`;
                });
            }

            runAI() {
                const ai = this.state.enemy;
                ai.assignments = { food: 0, wood: 0, gold: 0, stone: 0 };
                ai.idleWorkers = 0;
                const resources = [
                    { type: 'food', amount: ai.food },
                    { type: 'wood', amount: ai.wood },
                    { type: 'gold', amount: ai.gold }
                ];
                resources.sort((a, b) => a.amount - b.amount);
                ai.assignments[resources[0].type] = ai.workers;

                const eUnits = this.state.units.filter(u => u.owner === 'enemy');
                const myArchers = eUnits.filter(u => u.type === 'longbowman').length;
                const pUnits = this.state.units.filter(u => u.owner === 'player');
                const enemyArchers = pUnits.filter(u => u.type === 'longbowman').length;

                const pCountHalf = pUnits.filter(u => u.pos > 50).length;
                const eCountHalf = eUnits.filter(u => u.pos > 50).length;

                let playerFront = 0;
                if (pUnits.length > 0) playerFront = Math.max(...pUnits.map(u => u.pos));
                let enemyFront = 100;
                if (eUnits.length > 0) enemyFront = Math.min(...eUnits.map(u => u.pos));

                const distance = enemyFront - playerFront;
                const battleLine = (playerFront + enemyFront) / 2;

                let savingForTech = false;
                const blacksmith = ai.buildingInstances.find(b => b.type === 'blacksmith');

                // æ¿€è¿›ç­–ç•¥ï¼šå¦‚æœæˆ˜çº¿å‹åˆ¶(battleLine < 40)æˆ–å…µåŠ›å……è¶³ï¼Œå°±å°è¯•å‡ç§‘æŠ€
                const isPushing = battleLine < 40;

                if ((ai.armyCount > 5 || isPushing) && blacksmith && blacksmith.queue.length === 0) {
                    const levels = ai.techLevels;
                    let targetTech = null;

                    const checkTech = (type, lvl) => levels[type] < lvl ? `tech_${type}_${levels[type] + 1}` : null;

                    if (myArchers > 2 && levels.atk_r < levels.atk_m) targetTech = checkTech('atk_r', 3);
                    else if (enemyArchers > 3 && levels.def_r < levels.def_m) targetTech = checkTech('def_r', 3);

                    if (!targetTech) {
                        if (levels.atk_m < 1) targetTech = 'tech_atk_m_1';
                        else if (levels.def_m < 1) targetTech = 'tech_def_m_1';
                        else if (levels.atk_r < 1) targetTech = 'tech_atk_r_1';
                        else if (levels.def_r < 1) targetTech = 'tech_def_r_1';

                        else if (levels.atk_m < 2) targetTech = 'tech_atk_m_2';
                        else if (levels.def_m < 2) targetTech = 'tech_def_m_2';
                        else if (levels.atk_r < 2) targetTech = 'tech_atk_r_2';
                        else if (levels.def_r < 2) targetTech = 'tech_def_r_2';

                        else if (levels.atk_m < 3) targetTech = 'tech_atk_m_3';
                        else if (levels.def_m < 3) targetTech = 'tech_def_m_3';
                        else if (levels.atk_r < 3) targetTech = 'tech_atk_r_3';
                        else if (levels.def_r < 3) targetTech = 'tech_def_r_3';
                    }

                    if (targetTech) {
                        const techData = CONSTANTS.TECHS[targetTech];
                        const costF = techData.cost.food || 0;
                        const costW = techData.cost.wood || 0;
                        const costG = techData.cost.gold || 0;
                        const costS = techData.cost.stone || 0;

                        if (ai.food >= costF && ai.wood >= costW && ai.gold >= costG && ai.stone >= costS) {
                            ai.food -= costF; ai.wood -= costW; ai.gold -= costG; ai.stone -= costS;
                            blacksmith.queue.push({ type: targetTech, ticksLeft: techData.time, totalTicks: techData.time });
                        } else {
                            savingForTech = true;
                        }
                    }
                }

                if (!savingForTech) {
                    let pendingWorkers = 0;
                    ai.buildingInstances.forEach(b => { b.queue.forEach(q => { if (q.type === 'worker') pendingWorkers++; }); });

                    const clubmanCount = eUnits.filter(u => u.type === 'clubman').length;
                    const samuraiCount = eUnits.filter(u => u.type === 'samurai').length;

                    const buildings = [...ai.buildingInstances].sort((a, b) => a.type === 'towncenter' ? -1 : 1);
                    buildings.forEach(b => {
                        if (b.queue.length < 5) {
                            if (b.type === 'towncenter') {
                                if (ai.workers + pendingWorkers < 60) {
                                    this.aiQueue(ai, b, 'worker'); pendingWorkers++;
                                }
                            } else if (b.type === 'barracks') {
                                const samCost = CONSTANTS.UNITS.samurai.cost;
                                if (clubmanCount < 3) {
                                    this.aiQueue(ai, b, 'clubman');
                                } else if (ai.gold >= samCost.gold && samuraiCount < clubmanCount * 2) {
                                    this.aiQueue(ai, b, 'samurai');
                                } else {
                                    this.aiQueue(ai, b, 'clubman');
                                }
                            } else if (b.type === 'archery_range') {
                                const bowCost = CONSTANTS.UNITS.longbowman.cost;
                                if (ai.wood >= bowCost.wood + 50 && ai.food >= bowCost.food) {
                                    this.aiQueue(ai, b, 'longbowman');
                                }
                            }
                        }
                    });
                }

                const countType = (t) => {
                    const built = ai.buildingInstances.filter(b => b.type === t).length;
                    const constructing = ai.constructions.filter(c => c.type === t).length;
                    return built + constructing;
                };

                let structureToBuild = null;
                const numBarracks = countType('barracks');
                const numArchery = countType('archery_range');
                const numBlacksmith = countType('blacksmith');

                if (numBarracks < 1) structureToBuild = 'barracks';
                else if (numArchery < 1) structureToBuild = 'archery_range';
                else if (numBlacksmith < 1) structureToBuild = 'blacksmith';
                else if (numBarracks < 4 || ai.wood > 600) structureToBuild = 'barracks';
                else if (numArchery < 3 && ai.wood > 800) structureToBuild = 'archery_range';

                if (structureToBuild) {
                    const d = CONSTANTS.BUILDINGS[structureToBuild];
                    const cF = d.cost.food || 0;
                    const cW = d.cost.wood || 0;
                    const cS = d.cost.stone || 0;
                    if (ai.food >= cF && ai.wood >= cW && ai.stone >= cS) {
                        this.aiBuild(ai, structureToBuild);
                    }
                }

                let newStance = 'attack';

                if (eCountHalf > pCountHalf) {
                    newStance = 'attack';
                } else {
                    if (distance > 30) newStance = 'attack';
                    else {
                        if (battleLine > 65) newStance = 'defend'; else newStance = 'attack';
                    }
                }

                if (this.state.enemyStance !== newStance) this.state.enemyStance = newStance;
            }

            aiBuild(f, t) {
                const d = CONSTANTS.BUILDINGS[t]; const s = d.cost.stone || 0;
                if (f.food >= d.cost.food && f.wood >= d.cost.wood && f.stone >= s) {
                    f.food -= d.cost.food; f.wood -= d.cost.wood; f.stone -= s;
                    f.constructions.push({ id: Math.random(), type: t, ticksLeft: d.time, totalTicks: d.time });
                }
            }

            aiQueue(f, b, u) {
                const d = CONSTANTS.UNITS[u];
                if (f.food >= d.cost.food && f.wood >= d.cost.wood && f.gold >= (d.cost.gold || 0)) {
                    f.food -= d.cost.food; f.wood -= d.cost.wood; f.gold -= (d.cost.gold || 0);
                    b.queue.push({ type: u, ticksLeft: d.time, totalTicks: d.time });
                }
            }

            updateUI() {
                const p = this.state.player; const e = this.state.enemy;
                document.getElementById('p-base-hp').style.width = Math.max(0, (p.baseHp / CONSTANTS.BASE_HP * 100)) + '%';
                document.getElementById('e-base-hp').style.width = Math.max(0, (e.baseHp / CONSTANTS.BASE_HP * 100)) + '%';

                if (p.hasTurret) document.getElementById('p-base').classList.add('has-turret');
                if (e.hasTurret) document.getElementById('e-base').classList.add('has-turret');

                const toRoman = (n) => n === 0 ? '0' : (n === 1 ? 'I' : (n === 2 ? 'II' : 'III'));
                document.getElementById('p-tech-atk-m').innerText = `âš”ï¸ ${toRoman(p.techLevels.atk_m)}`;
                document.getElementById('p-tech-def-m').innerText = `ğŸ›¡ï¸ ${toRoman(p.techLevels.def_m)}`;
                document.getElementById('p-tech-atk-r').innerText = `ğŸ¹ ${toRoman(p.techLevels.atk_r)}`;
                document.getElementById('p-tech-def-r').innerText = `ğŸ¯ ${toRoman(p.techLevels.def_r)}`;

                document.getElementById('e-tech-atk-m').innerText = `âš”ï¸ ${toRoman(e.techLevels.atk_m)}`;
                document.getElementById('e-tech-def-m').innerText = `ğŸ›¡ï¸ ${toRoman(e.techLevels.def_m)}`;
                document.getElementById('e-tech-atk-r').innerText = `ğŸ¹ ${toRoman(e.techLevels.atk_r)}`;
                document.getElementById('e-tech-def-r').innerText = `ğŸ¯ ${toRoman(e.techLevels.def_r)}`;

                const currentPop = p.workers + p.armyCount;
                const popEl = document.getElementById('disp-pop');
                popEl.innerText = `${currentPop}/${p.popCap}`;
                popEl.style.color = '#e5e5e5';
                if (currentPop >= p.popCap) popEl.style.color = '#ef4444';
                else if (currentPop >= p.popCap * 0.8) popEl.style.color = '#eab308';

                const idleEl = document.getElementById('disp-idle'); idleEl.innerText = p.idleWorkers;
                if (p.idleWorkers > 0) idleEl.classList.add('warning'); else idleEl.classList.remove('warning');

                ['food', 'wood', 'gold', 'stone'].forEach(r => {
                    document.getElementById(`res-stock-${r}`).innerText = Math.floor(p[r]);
                    document.getElementById(`res-workers-${r}`).innerText = p.assignments[r];
                    const btnAdd = document.getElementById(`add-${r}`);
                    const btnSub = document.getElementById(`sub-${r}`);
                    if (p.idleWorkers > 0) btnAdd.classList.remove('disabled'); else btnAdd.classList.add('disabled');
                    if (p.assignments[r] > 0) btnSub.classList.remove('disabled'); else btnSub.classList.add('disabled');
                });

                this.updateDockProgress();
                if (this.state.selectedDockId) this.refreshPopoverState();
            }

            renderDock() {
                const dock = document.getElementById('dock'); dock.innerHTML = ''; const p = this.state.player;
                const houses = p.buildingInstances.filter(b => b.type === 'house');
                const builtBuildings = p.buildingInstances.filter(b => b.type !== 'house').map(b => ({ ...b, isConstruction: false }));
                const underConstruction = p.constructions.map(c => ({ ...c, isConstruction: true }));
                const mixedList = [...builtBuildings, ...underConstruction];
                mixedList.sort((a, b) => {
                    const order = { towncenter: 1, barracks: 2, archery_range: 3, blacksmith: 4 };
                    return (order[a.type] || 99) - (order[b.type] || 99);
                });
                mixedList.forEach(item => {
                    if (item.isConstruction) {
                        const icon = this.createDockIcon(`const-${item.id}`, CONSTANTS.BUILDINGS[item.type].icon, true);
                        dock.appendChild(icon);
                    } else {
                        const icon = this.createDockIcon(item.id, CONSTANTS.BUILDINGS[item.type].icon, false);
                        icon.onclick = () => this.toggleDockItem(item.id);
                        dock.appendChild(icon);
                    }
                });
                if (houses.length > 0) { const icon = this.createDockIcon('group-house', CONSTANTS.BUILDINGS['house'].icon, false); icon.onclick = () => this.toggleDockItem('group-house'); icon.querySelector('.icon-badge').style.display = 'flex'; icon.querySelector('.icon-badge').classList.add('house-badge'); icon.querySelector('.icon-badge').innerText = houses.length; dock.appendChild(icon); }
                const hammer = this.createDockIcon('dock-build_menu', 'ğŸ”¨', false); hammer.classList.add('build-icon'); hammer.onclick = () => this.toggleDockItem('build_menu'); dock.appendChild(hammer);
                this.updateDockVisuals();
            }

            createDockIcon(id, emoji, isConstructing) {
                const icon = document.createElement('div'); icon.className = `dock-icon ${isConstructing ? 'constructing' : ''}`;
                icon.id = `dock-elem-${id}`; icon.dataset.refId = id; icon.innerHTML = emoji;
                if (isConstructing) { const overlay = document.createElement('div'); overlay.className = 'const-overlay'; icon.appendChild(overlay); }
                const barBg = document.createElement('div'); barBg.className = 'icon-progress-bg'; const barFill = document.createElement('div'); barFill.className = 'icon-progress-fill'; barBg.appendChild(barFill); icon.appendChild(barBg);
                const badge = document.createElement('div'); badge.className = 'icon-badge'; badge.style.display = 'none'; icon.appendChild(badge);
                return icon;
            }

            updateDockProgress() {
                const p = this.state.player;
                p.buildingInstances.forEach(b => {
                    if (b.type === 'house') return;
                    const el = document.getElementById(`dock-elem-${b.id}`);
                    if (el) {
                        const barBg = el.querySelector('.icon-progress-bg'); const bar = el.querySelector('.icon-progress-fill'); const badge = el.querySelector('.icon-badge');
                        if (b.queue.length > 0) {
                            const t = b.queue[0];
                            bar.style.width = (100 - (t.ticksLeft / t.totalTicks * 100)) + '%';
                            badge.style.display = 'flex'; badge.innerText = b.queue.length; barBg.style.display = 'block';
                            if (CONSTANTS.TECHS[t.type]) el.classList.add('researching'); else el.classList.remove('researching');
                        } else {
                            bar.style.width = '0%'; badge.style.display = 'none'; barBg.style.display = 'none'; el.classList.remove('researching');
                        }
                    }
                });
                const houseCount = p.buildingInstances.filter(b => b.type === 'house').length;
                const hIcon = document.getElementById('dock-elem-group-house');
                if (hIcon) { hIcon.querySelector('.icon-badge').innerText = houseCount; if (hIcon.querySelector('.icon-progress-bg')) hIcon.querySelector('.icon-progress-bg').style.display = 'none'; }
                p.constructions.forEach(task => {
                    const el = document.getElementById(`dock-elem-const-${task.id}`);
                    if (el) {
                        const bar = el.querySelector('.icon-progress-fill'); const overlay = el.querySelector('.const-overlay');
                        const pct = Math.floor(100 - (task.ticksLeft / task.totalTicks * 100)); bar.style.width = pct + '%'; overlay.innerText = pct + '%'; el.querySelector('.icon-progress-bg').style.display = 'block';
                    }
                });
            }

            updateDockVisuals() {
                const dock = document.getElementById('dock');
                Array.from(dock.children).forEach(el => {
                    const logicalId = el.id === 'dock-elem-dock-build_menu' ? 'build_menu' : el.dataset.refId;
                    if (this.state.selectedDockId === logicalId) el.classList.add('active'); else el.classList.remove('active');
                });
            }

            buildPopover() {
                const container = document.getElementById('popover-container');
                const id = this.state.selectedDockId;
                if (!id) { container.style.display = 'none'; return; }
                container.innerHTML = ''; container.style.display = 'flex';
                const domId = id === 'build_menu' ? 'dock-elem-dock-build_menu' : `dock-elem-${id}`;
                const icon = document.getElementById(domId);
                if (icon) { const rect = icon.getBoundingClientRect(); container.style.left = (rect.left + rect.width / 2) + 'px'; }

                const p = this.state.player;
                if (id === 'build_menu') {
                    container.innerHTML = `<div class="popover-title">å»ºé€ </div>`;
                    ['house', 'barracks', 'archery_range', 'blacksmith', 'towncenter'].forEach(t => {
                        const d = CONSTANTS.BUILDINGS[t];
                        const btn = document.createElement('div'); btn.className = 'menu-btn build-action-btn'; btn.dataset.type = t;
                        btn.onclick = () => this.playerBuildStructure(t);
                        let cost = []; if (d.cost.food) cost.push(`${d.cost.food}è‚‰`); if (d.cost.wood) cost.push(`${d.cost.wood}æœ¨`); if (d.cost.stone) cost.push(`${d.cost.stone}çŸ³`);
                        btn.innerHTML = `<span class="btn-icon">${d.icon}</span><div class="btn-info"><span>${d.label}</span><span class="btn-cost">${cost.join(' ')}</span></div>`;
                        container.appendChild(btn);
                    });
                } else if (id === 'group-house') {
                    container.innerHTML = `<div class="popover-title">æˆ¿å±‹</div><div class="p-2 text-sm text-gray-300 text-center">æˆ¿å±‹ç”¨äºå¢åŠ äººå£</div>`;
                } else {
                    const b = p.buildingInstances.find(x => x.id === id);
                    if (b) {
                        const buildingLabel = CONSTANTS.BUILDINGS[b.type].label;
                        container.innerHTML = `<div class="popover-title">${buildingLabel}</div>`;
                        const statusDiv = document.createElement('div');
                        statusDiv.id = 'popover-prog-status';
                        statusDiv.className = 'text-xs text-blue-400 text-center mb-2 font-bold';
                        statusDiv.style.display = 'none';
                        container.appendChild(statusDiv);

                        if (b.type === 'towncenter' || b.type === 'barracks' || b.type === 'archery_range') {
                            let unitTypes = [];
                            if (b.type === 'towncenter') unitTypes = ['worker'];
                            else if (b.type === 'barracks') unitTypes = ['clubman', 'samurai'];
                            else if (b.type === 'archery_range') unitTypes = ['longbowman'];
                            unitTypes.forEach(uType => {
                                const u = CONSTANTS.UNITS[uType];
                                const btn = document.createElement('div'); btn.className = 'menu-btn produce-action-btn'; btn.dataset.type = uType;
                                btn.onclick = () => this.playerQueueUnit(id, uType);
                                let cost = []; if (u.cost.food) cost.push(`${u.cost.food}è‚‰`); if (u.cost.wood) cost.push(`${u.cost.wood}æœ¨`); if (u.cost.gold) cost.push(`${u.cost.gold}é‡‘`);
                                btn.innerHTML = `<span class="btn-icon">${uType === 'worker' ? 'ğŸ‘·' : (uType === 'longbowman' ? 'ğŸ¹' : 'âš”ï¸')}</span><div class="btn-info"><span>è®­ç»ƒ${u.label}</span><span class="btn-cost">${cost.join(' ')}</span></div>`;
                                container.appendChild(btn);
                            });
                        }

                        if (b.type === 'towncenter') {
                            const isQueuingTurret = p.buildingInstances.some(bi => bi.queue.some(q => q.type === 'turret_tech'));
                            if (!p.hasTurret && !isQueuingTurret) {
                                const tech = CONSTANTS.TECHS.turret_tech;
                                const techBtn = document.createElement('div'); techBtn.className = 'menu-btn tech-btn'; techBtn.dataset.tech = 'turret_tech';
                                techBtn.onclick = () => this.playerQueueTech(id, 'turret_tech');
                                let tCost = []; if (tech.cost.gold) tCost.push(`${tech.cost.gold}é‡‘`); if (tech.cost.stone) tCost.push(`${tech.cost.stone}çŸ³`);
                                techBtn.innerHTML = `<span class="btn-icon">${tech.icon}</span><div class="btn-info"><span>ç ”å‘${tech.label}</span><span class="btn-cost">${tCost.join(' ')}</span></div>`;
                                container.appendChild(techBtn);
                            }
                        }

                        if (b.type === 'blacksmith') {
                            const ongoingTechs = new Set();
                            p.buildingInstances.forEach(bi => {
                                bi.queue.forEach(q => {
                                    if (q.type.startsWith('tech_')) ongoingTechs.add(q.type);
                                });
                            });

                            const techLevels = p.techLevels;
                            const techTypes = ['atk_m', 'def_m', 'atk_r', 'def_r'];
                            let anyUpgradeAvailable = false;
                            const isThisBuildingBusy = b.queue.length > 0;

                            if (!isThisBuildingBusy) {
                                techTypes.forEach(type => {
                                    const currentLvl = techLevels[type];
                                    const nextLvl = currentLvl + 1;
                                    const techId = `tech_${type}_${nextLvl}`;

                                    if (currentLvl < 3 && !ongoingTechs.has(techId)) {
                                        anyUpgradeAvailable = true;
                                        const tech = CONSTANTS.TECHS[techId];

                                        const techBtn = document.createElement('div'); techBtn.className = 'menu-btn tech-btn'; techBtn.dataset.tech = techId;
                                        techBtn.onclick = () => this.playerQueueTech(id, techId);

                                        let tCost = [];
                                        if (tech.cost.wood) tCost.push(`${tech.cost.wood}æœ¨`);
                                        if (tech.cost.food) tCost.push(`${tech.cost.food}è‚‰`);
                                        if (tech.cost.gold) tCost.push(`${tech.cost.gold}é‡‘`);

                                        techBtn.innerHTML = `<span class="btn-icon">${tech.icon}</span><div class="btn-info"><span>${tech.label}</span><span class="btn-cost">${tCost.join(' ')}</span></div>`;
                                        container.appendChild(techBtn);
                                    }
                                });
                            }

                            if (!anyUpgradeAvailable && !isThisBuildingBusy) {
                                container.innerHTML += `<div class="text-xs text-gray-400 text-center mt-2">æ‰€æœ‰å¯ç”¨ç§‘æŠ€å‡åœ¨ç ”å‘ä¸­æˆ–å·²æ»¡çº§</div>`;
                            }
                        }
                        const q = document.createElement('div'); q.id = 'popover-queue-info'; q.className = 'text-xs text-gray-400 text-center mt-1'; container.appendChild(q);
                    }
                }
                this.refreshPopoverState();
            }

            refreshPopoverState() {
                const id = this.state.selectedDockId; if (!id || id === 'group-house') return;
                const p = this.state.player;
                if (id === 'build_menu') {
                    document.querySelectorAll('.build-action-btn').forEach(btn => {
                        const t = btn.dataset.type; const d = CONSTANTS.BUILDINGS[t];
                        const s = d.cost.stone || 0; const f = d.cost.food || 0; const w = d.cost.wood || 0;
                        if (p.food >= f && p.wood >= w && p.stone >= s) btn.removeAttribute('disabled'); else btn.setAttribute('disabled', 'true');
                    });
                } else {
                    const b = p.buildingInstances.find(x => x.id === id);
                    if (!b) { this.closePopover(); return; }

                    const statusEl = document.getElementById('popover-prog-status');
                    if (statusEl) {
                        if (b.queue.length > 0) {
                            const currentItem = b.queue[0];
                            let itemLabel = '';
                            let action = 'ç”Ÿäº§';
                            if (CONSTANTS.UNITS[currentItem.type]) itemLabel = CONSTANTS.UNITS[currentItem.type].label;
                            else if (CONSTANTS.TECHS[currentItem.type]) { itemLabel = CONSTANTS.TECHS[currentItem.type].label; action = 'ç ”å‘'; }

                            const progress = Math.floor(100 - (currentItem.ticksLeft / currentItem.totalTicks * 100));
                            statusEl.innerText = `æ­£åœ¨${action}: ${itemLabel} (${progress}%)`;
                            statusEl.style.color = action === 'ç ”å‘' ? '#22c55e' : '#60a5fa';
                            statusEl.style.display = 'block';
                        } else {
                            statusEl.style.display = 'none';
                        }
                    }

                    document.querySelectorAll('.produce-action-btn').forEach(btn => {
                        const t = btn.dataset.type; const u = CONSTANTS.UNITS[t];
                        const f = u.cost.food || 0; const w = u.cost.wood || 0; const g = u.cost.gold || 0;
                        if (p.food >= f && p.wood >= w && p.gold >= g) btn.removeAttribute('disabled'); else btn.setAttribute('disabled', 'true');
                    });
                    document.querySelectorAll('.tech-btn').forEach(btn => {
                        const tId = btn.dataset.tech; const t = CONSTANTS.TECHS[tId];
                        const f = t.cost.food || 0; const w = t.cost.wood || 0; const g = t.cost.gold || 0; const s = t.cost.stone || 0;
                        if (p.food >= f && p.wood >= w && p.gold >= g && p.stone >= s) btn.removeAttribute('disabled'); else btn.setAttribute('disabled', 'true');
                    });
                    const qInfo = document.getElementById('popover-queue-info'); if (qInfo) qInfo.innerText = `é˜Ÿåˆ—: ${b.queue.length}`;
                }
            }

            updateUnits() {
                // 1. è·å–åŒæ–¹å•ä½
                let p = this.state.units.filter(u => u.owner === 'player');
                // ç”µè„‘åˆ—è¡¨å›ºå®šä»å°åˆ°å¤§ï¼ˆå·¦->å³ï¼‰
                let e = this.state.units.filter(u => u.owner === 'enemy').sort((a, b) => a.pos - b.pos);

                // 2. ç©å®¶è‡ªèº«çš„æ’åº
                if (this.state.playerStance === 'attack') p.sort((a, b) => b.pos - a.pos);
                else p.sort((a, b) => a.pos - b.pos);

                // 3. å‡†å¤‡å…¨è½¨é“ç¢°æ’åˆ—è¡¨
                const pForCollision = [...p].sort((a, b) => b.pos - a.pos); // ä»å³åˆ°å·¦ï¼Œç”¨äºæ•Œäººç¢°æ’æ£€æµ‹
                const eForCollision = [...e]; // ä»å·¦åˆ°å³ï¼Œç”¨äºç©å®¶ç¢°æ’æ£€æµ‹

                // 4. å¤„ç†ç©å®¶é€»è¾‘
                p.forEach((u, i) => {
                    this.processCombat(u, e, 1);
                    // å‹å†›ç¢°æ’ï¼šä»…é™åŒè½¨é“
                    const friendsInLane = p.filter(f => f.lane === u.lane);
                    const laneIndex = friendsInLane.findIndex(f => f.id === u.id);
                    // æ•Œå†›ç¢°æ’ï¼šå…¨è½¨é“ (ä½¿ç”¨æ‰€æœ‰æ•Œäººåˆ—è¡¨)
                    this.processMovement(u, friendsInLane, eForCollision, laneIndex, 1);
                });

                // 5. å¤„ç†ç”µè„‘é€»è¾‘
                e.forEach((u, i) => {
                    this.processCombat(u, p, -1);
                    // å‹å†›ç¢°æ’ï¼šä»…é™åŒè½¨é“
                    const friendsInLane = e.filter(f => f.lane === u.lane);
                    const laneIndex = friendsInLane.findIndex(f => f.id === u.id);
                    // æ•Œå†›ç¢°æ’ï¼šå…¨è½¨é“ (ä½¿ç”¨æ‰€æœ‰ç©å®¶åˆ—è¡¨)
                    this.processMovement(u, friendsInLane, pForCollision, laneIndex, -1);
                });

                // 6. æ¸…ç†æ­»äº¡å•ä½
                const dead = this.state.units.filter(u => u.hp <= 0);
                dead.forEach(u => this.handleUnitDeath(u));
                this.state.units = this.state.units.filter(u => u.hp > 0);

                // 7. èƒœè´Ÿåˆ¤å®š
                if (this.state.player.baseHp <= 0) this.endGame('DEFEAT', 'ä½ çš„å¸å›½é™·è½äº†ã€‚');
                if (this.state.enemy.baseHp <= 0) this.endGame('VICTORY', 'ä½ å¾æœäº†é‡è›®äººï¼');
            }

            handleUnitDeath(u) {
                const f = u.owner === 'player' ? this.state.player : this.state.enemy;
                if (CONSTANTS.UNITS[u.type].type === 'eco') {
                    if (f.workers > 0) {
                        f.workers--;
                        if (f.idleWorkers > 0) f.idleWorkers--;
                        else {
                            for (const r of ['stone', 'gold', 'wood', 'food']) if (f.assignments[r] > 0) { f.assignments[r]--; break; }
                        }
                    }
                } else { f.armyCount = Math.max(0, f.armyCount - 1); }
            }

            processCombat(u, ens, dir) {
                if (u.attackAnimTimer > 0) u.attackAnimTimer--; if (u.attackCooldown > 0) u.attackCooldown--;
                // è·¨è½¨é“æ”»å‡»ï¼šåªè¦Xè½´è·ç¦»è¶³å¤Ÿè¿‘
                let v = ens.filter(e => Math.abs(u.pos - e.pos) <= u.range);

                let t = null;
                if (v.length > 0) {
                    // ä¼˜å…ˆæ”»å‡»æœ€è¿‘çš„æ•Œäºº
                    v.sort((a, b) => Math.abs(u.pos - a.pos) - Math.abs(u.pos - b.pos));
                    t = v[0];
                }
                else if (Math.abs(u.pos - (dir === 1 ? 100 : 0)) <= u.range) t = "base";

                if (t) {
                    u.state = 'attack'; u.targetId = (t === "base") ? "base" : t.id;
                    if (u.attackCooldown <= 0) {
                        u.attackCooldown = CONSTANTS.UNITS[u.type].cooldown || 10;
                        u.attackAnimTimer = 3; const dmg = u.dmg;
                        if (t === "base") {
                            // åŸºåœ°é˜²å¾¡2ï¼Œæ‰€æœ‰æ”»å‡»å‡æŒ‰2å‡å…
                            const baseDef = 2;
                            const actualDmg = Math.max(1, dmg - baseDef);
                            if (u.owner === 'player') this.state.enemy.baseHp -= actualDmg;
                            else this.state.player.baseHp -= actualDmg;
                            this.spawnFloater(dir === 1 ? 95 : 5, `-${actualDmg}`, '#f00');
                        }
                        else {
                            const uData = CONSTANTS.UNITS[u.type];
                            const atkType = uData.attackType || 'melee'; // é»˜è®¤ä¸ºè¿‘æˆ˜
                            let defVal = 0;
                            if (atkType === 'ranged') defVal = t.def_r;
                            else defVal = t.def_m;

                            let actualDmg = Math.max(1, dmg - defVal);
                            t.hp -= actualDmg;
                            this.spawnFloater(t.pos, `-${actualDmg}`, '#fff');
                        }
                    }
                } else { u.state = 'move'; }
            }

            processMovement(u, friends, enemies, i, dir) {
                // è¿œç¨‹å…µç§ç‰¹æ€§ï¼šå¦‚æœæ­£åœ¨æ”»å‡»ï¼ˆå°„ç¨‹å†…æœ‰æ•Œäººï¼‰ï¼Œä¸”å±æ€§è¦æ±‚åœæ­¢ï¼Œåˆ™åœæ­¢ç§»åŠ¨
                if (u.stopOnAttack && u.state === 'attack') return;

                let d = u.pos;
                const s = u.owner === 'player' ? this.state.playerStance : this.state.enemyStance;
                let speed = u.speed;
                if (dir === -1) speed = -speed;

                if (s === 'attack') {
                    d += speed;
                    // å‹å†›å †å æ£€æµ‹
                    if (i > 0) {
                        const l = friends[i - 1].pos - (dir * u.width);
                        if (dir === 1 ? d > l : d < l) d = l;
                    }
                    // æ•Œå†›é˜»æŒ¡æ£€æµ‹ (enemies åŒ…å«æ‰€æœ‰è½¨é“çš„æ•Œäºº)
                    if (enemies.length > 0) {
                        const l = enemies[0].pos - (dir * u.width);
                        // åªæœ‰åœ¨çœŸçš„ç¢°åˆ°æ•Œäººç¢°æ’ç®±æ—¶æ‰åœä¸‹
                        if (dir === 1 ? d > l : d < l) d = l;
                    }
                    // ç§»åŠ¨è¾¹ç•Œ
                    else if (dir === 1 ? d > 98 : d < 2) {
                        d = dir === 1 ? 98 : 2;
                    }
                } else {
                    if (s === 'defend') {
                        d -= speed;
                    }
                    if (dir === 1) {
                        let limit = 5;
                        if (i > 0) limit = friends[i - 1].pos + u.width;
                        if (d < limit) d = limit;
                    } else {
                        let limit = 95;
                        if (i < friends.length - 1) {
                            limit = friends[i + 1].pos - u.width;
                        }
                        if (d > limit) d = limit;
                    }
                }
                u.pos = Math.min(100, Math.max(0, d));
            }

            spawnFloater(x, t, c) { const el = document.createElement('div'); el.className = 'floater'; const r = document.getElementById('game-wrapper').getBoundingClientRect(); el.style.left = (x / 100 * r.width) + 'px'; el.style.top = (r.height / 2 - 20) + 'px'; el.style.color = c; el.innerText = t; document.getElementById('game-wrapper').appendChild(el); setTimeout(() => el.remove(), 1000); }
            showToast(msg, c = '#ef4444') { const el = document.createElement('div'); el.className = 'toast text-white px-4 py-2 rounded shadow-lg font-bold'; el.style.background = c; el.innerText = msg; document.getElementById('toast-container').appendChild(el); setTimeout(() => el.remove(), 2000); }

            loop() { if (!this.gameOver) { this.draw(); requestAnimationFrame(() => this.loop()); } }

            draw() {
                const w = this.canvas.width; const h = this.canvas.height;

                // --- 1. æ¸…é™¤ä¸¤ä¸ªç”»å¸ƒ ---
                this.ctx.clearRect(0, 0, w, h);
                this.bgCtx.clearRect(0, 0, w, h);

                // --- 2. åœ¨ bgCanvas ç”»è½¨é“çº¿ (è¢«åŸºåœ°é®æŒ¡) ---
                // è½¨é“1ï¼ˆä¸Šå±‚ï¼Œè¿œç¨‹ï¼‰ï¼šå®çº¿ï¼Œä½ç½® h/2 - 20
                this.bgCtx.strokeStyle = '#555';
                this.bgCtx.beginPath();
                this.bgCtx.moveTo(0, h / 2 - 20);
                this.bgCtx.lineTo(w, h / 2 - 20);
                this.bgCtx.stroke();

                // è½¨é“2ï¼ˆä¸‹å±‚ï¼Œè¿‘æˆ˜ï¼‰ï¼šå®çº¿ï¼Œä½ç½® h/2 + 20
                this.bgCtx.strokeStyle = '#555';
                this.bgCtx.beginPath();
                this.bgCtx.moveTo(0, h / 2 + 20);
                this.bgCtx.lineTo(w, h / 2 + 20);
                this.bgCtx.stroke();

                // --- 3. åœ¨ gameCanvas ç”»å•ä½å’Œç‰¹æ•ˆ (åœ¨åŸºåœ°ä¸Šå±‚) ---
                this.state.turretShots.forEach(shot => {
                    this.ctx.strokeStyle = shot.color; this.ctx.lineWidth = 3; this.ctx.beginPath();
                    this.ctx.moveTo((shot.start / 100) * w, h / 2); this.ctx.lineTo((shot.end / 100) * w, h / 2); this.ctx.stroke();
                    this.ctx.fillStyle = 'white'; this.ctx.beginPath(); this.ctx.arc((shot.end / 100) * w, h / 2, 5, 0, Math.PI * 2); this.ctx.fill();
                });

                this.state.units.forEach(u => {
                    const x = (u.pos / 100) * w;
                    const laneY = u.lane === 1 ? (h / 2 - 20) : (h / 2 + 20);

                    this.ctx.fillStyle = u.owner === 'player' ? '#3b82f6' : '#ef4444';

                    if (u.type === 'samurai') {
                        this.ctx.fillRect(x - 8, laneY - 20, 16, 20);
                    } else if (u.type === 'clubman') {
                        this.ctx.beginPath(); this.ctx.arc(x, laneY - 8, 8, 0, Math.PI * 2); this.ctx.fill();
                    } else if (u.type === 'longbowman') {
                        this.ctx.fillStyle = u.owner === 'player' ? '#8b5cf6' : '#a855f7';
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, laneY - 20);
                        this.ctx.lineTo(x - 6, laneY);
                        this.ctx.lineTo(x + 6, laneY);
                        this.ctx.fill();
                    } else {
                        this.ctx.fillRect(x - 5, laneY - 15, 10, 15);
                    }

                    this.ctx.fillStyle = '#ccc';
                    if (u.type === 'clubman') {
                        this.ctx.fillRect(u.owner === 'player' ? x + 2 : x - 12, laneY - 10, 10, 2);
                    } else if (u.type === 'longbowman') {
                        // å¼“ç®­æ‰‹ä¸ç”»è¿‘æˆ˜æ¡
                    } else {
                        this.ctx.fillRect(u.owner === 'player' ? x + 5 : x - 5, laneY - 15, 8, 2);
                    }

                    if (u.attackAnimTimer > 0) {
                        this.ctx.strokeStyle = '#ffff00'; this.ctx.lineWidth = 2; this.ctx.beginPath();
                        this.ctx.moveTo(u.owner === 'player' ? x + 5 : x - 5, laneY - 15 + (Math.random() * 6 - 3));
                        let tx = u.owner === 'player' ? x + 30 : x - 30; let ty = laneY - 10;
                        if (u.targetId === "base") tx = u.owner === 'player' ? w - 40 : 40; else {
                            const t = this.state.units.find(k => k.id === u.targetId);
                            if (t) {
                                tx = (t.pos / 100) * w;
                                const targetLaneY = t.lane === 1 ? (h / 2 - 20) : (h / 2 + 20);
                                ty = targetLaneY - 10;
                            }
                        }
                        this.ctx.lineTo(tx, ty); this.ctx.stroke();
                    }
                    const hp = u.hp / u.maxHp; this.ctx.fillStyle = 'red'; this.ctx.fillRect(x - 8, laneY - 25, 16, 3); this.ctx.fillStyle = '#0f0'; this.ctx.fillRect(x - 8, laneY - 25, 16 * hp, 3);
                });
            }
            endGame(r, m) { this.gameOver = true; clearInterval(this.logicInterval); document.getElementById('game-over').style.display = 'flex'; document.getElementById('end-title').innerText = r; document.getElementById('end-title').className = r === 'VICTORY' ? 'text-5xl font-bold mb-4 text-green-500' : 'text-5xl font-bold mb-4 text-red-500'; document.getElementById('end-reason').innerText = m; }
        }
        const game = new Game();

        // --- Cheat Code ---
        window.show_me_the_money = function () {
            if (game && game.state && game.state.player) {
                game.state.player.food = 9999;
                game.state.player.wood = 9999;
                game.state.player.gold = 9999;
                game.state.player.stone = 9999;
                game.updateUI();
                console.log("Resources granted: 9999 [Food, Wood, Gold, Stone]");
            }
        }
    </script>
</body>

</html>
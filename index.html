<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æœ´ç´ å¸å›½ - Minimalist Empire</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #111;
            color: #e5e5e5;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            user-select: none;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #game-wrapper {
            position: relative;
            flex: 1;
            overflow: hidden;
            background: #262626;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* åŸºåœ°ä½ç½®å‚ç›´å±…ä¸­ */
        .base {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 80px;
            height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            z-index: 10;
            pointer-events: none;
        }

        .base-player {
            left: 0;
            background: #3b82f6;
            border-right: 4px solid #1d4ed8;
        }

        .base-enemy {
            right: 0;
            background: #ef4444;
            border-left: 4px solid #b91c1c;
        }

        /* ç‚®å°è§†è§‰è£…é¥° */
        .turret-addon {
            position: absolute;
            top: -20px;
            width: 40px;
            height: 20px;
            background: #555;
            border: 2px solid #ccc;
            border-radius: 5px 5px 0 0;
            display: none;
        }

        .has-turret .turret-addon {
            display: block;
        }

        .hp-bar-bg {
            width: 80%;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            margin-top: 5px;
        }

        .hp-bar-fill {
            height: 100%;
            background: #22c55e;
            width: 100%;
            transition: width 0.2s;
        }

        /* UI ç»„ä»¶ */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* é¡¶éƒ¨å¯¹é½ */
            padding: 10px 20px;
            pointer-events: none;
            z-index: 20;
        }

        .top-group {
            display: flex;
            flex-direction: column;
        }
        .top-group.right {
            align-items: flex-end;
        }

        .top-item {
            font-weight: bold;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px black;
            line-height: 1.2;
        }
        
        /* æ–°å¢ï¼šç§‘æŠ€çŠ¶æ€æ˜¾ç¤º */
        .tech-status {
            font-family: monospace;
            font-size: 0.9rem;
            font-weight: bold;
            margin-top: 2px;
            text-shadow: 1px 1px 1px black;
            opacity: 0.9;
        }

        .text-blue { color: #60a5fa; }
        .text-red { color: #f87171; }
        .text-blue-light { color: #93c5fd; }
        .text-red-light { color: #fca5a5; }

        .tactics-bar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 30;
            pointer-events: auto;
        }

        .tactic-btn {
            background: rgba(30, 30, 30, 0.6);
            border: 1px solid #555;
            color: #ccc;
            padding: 6px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
            font-size: 0.85rem;
        }

        .tactic-btn:hover {
            background: #444;
            color: white;
        }

        .tactic-btn.active {
            background: #2563eb;
            border-color: #60a5fa;
            color: white;
            box-shadow: 0 0 8px #2563eb;
        }

        /* èµ„æºé¢æ¿ */
        .resource-widget {
            position: absolute;
            bottom: 100px;
            left: 20px;
            width: 280px;
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            z-index: 40;
            backdrop-filter: blur(8px);
        }

        @media (max-height: 500px) {
            .resource-widget {
                bottom: 90px;
                left: 10px;
                transform: scale(0.9);
                transform-origin: bottom left;
            }
        }

        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            margin-bottom: 8px;
            border-bottom: 1px solid #4b5563;
            font-size: 1rem;
        }

        .status-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .icon-house {
            color: #f59e0b;
        }

        .pop-text {
            font-weight: bold;
            font-family: monospace;
            transition: color 0.2s;
        }

        .icon-sleep {
            color: #9ca3af;
        }

        .idle-text {
            color: #9ca3af;
            font-weight: bold;
            font-family: monospace;
        }

        .idle-text.warning {
            color: #ef4444;
            animation: pulse 1s infinite;
        }

        .res-grid {
            display: grid;
            grid-template-columns: 24px 1fr 24px 50px 24px;
            gap: 4px;
            align-items: center;
            font-size: 0.9rem;
        }

        .res-icon {
            text-align: center;
            font-size: 1rem;
        }

        .res-val {
            font-family: monospace;
            text-align: right;
            padding-right: 10px;
            color: #e5e5e5;
            font-weight: bold;
        }

        .worker-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            height: 24px;
        }

        .res-w-icon {
            color: #9ca3af;
            font-size: 0.7rem;
        }

        .res-w-val {
            color: #60a5fa;
            font-family: monospace;
            font-weight: bold;
        }

        .tiny-btn {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #374151;
            border: 1px solid #4b5563;
            border-radius: 4px;
            cursor: pointer;
            color: #ccc;
            font-size: 0.9rem;
            line-height: 0;
            transition: background 0.1s;
        }

        .tiny-btn:hover {
            background: #4b5563;
            color: white;
        }

        .tiny-btn.disabled {
            opacity: 0.2;
            cursor: default;
            pointer-events: none;
        }

        /* Dock æ  */
/* Dock æ  */
        .dock-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 8px;
            border-radius: 16px;
            display: flex;
            gap: 12px;
            z-index: 50;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);

            /* --- æ–°å¢/ä¿®æ”¹çš„ä»£ç å¼€å§‹ --- */
            max-width: 95vw;       /* é™åˆ¶æœ€å¤§å®½åº¦ä¸ºå±å¹•å®½åº¦çš„ 95% */
            overflow-x: auto;      /* å…è®¸æ¨ªå‘æ»šåŠ¨ */
            
            /* éšè—æ»šåŠ¨æ¡ (Chrome/Safari/Webkit) */
            -webkit-overflow-scrolling: touch; /* iOS å¹³æ»‘æ»šåŠ¨ */
            scrollbar-width: none; /* Firefox éšè—æ»šåŠ¨æ¡ */
            -ms-overflow-style: none;  /* IE 10+ éšè—æ»šåŠ¨æ¡ */
        }
        
        /* éšè—æ»šåŠ¨æ¡çš„ä¼ªå…ƒç´  */
        .dock-container::-webkit-scrollbar { 
            display: none; 
        }
        /* --- æ–°å¢/ä¿®æ”¹çš„ä»£ç ç»“æŸ --- */

        .dock-icon {
            width: 56px;
            height: 56px;
            background: #2d2d2d;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            cursor: pointer;
            position: relative;
            transition: transform 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: 1px solid #444;
            
            /* --- æ–°å¢ä»£ç  --- */
            flex-shrink: 0; /* ç¦æ­¢å›¾æ ‡åœ¨ç©ºé—´ä¸è¶³æ—¶ç¼©å°ï¼Œå¼ºåˆ¶è§¦å‘æ»šåŠ¨ */
        }

        .dock-icon:hover {
            transform: translateY(-5px) scale(1.1);
            background: #3d3d3d;
            z-index: 60;
        }

        .dock-icon.active {
            background: #333;
            box-shadow: 0 0 0 2px #3b82f6;
            transform: translateY(-5px);
        }

        .dock-icon.build-icon {
            background: #eab308;
            color: #000;
            border-color: #ca8a04;
        }

        .dock-icon.build-icon:hover {
            background: #facc15;
        }

        .dock-icon.constructing {
            opacity: 0.7;
            border-style: dashed;
            background: #1f2937;
        }

        .dock-icon.constructing .const-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            font-size: 12px;
            color: #eab308;
            font-weight: bold;
        }

        .icon-progress-bg {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            overflow: hidden;
            display: none;
        }

        .icon-progress-fill {
            height: 100%;
            width: 0%;
            background: #3b82f6;
            transition: width linear 0.1s;
        }
        .constructing .icon-progress-fill {
            background: #eab308;
        }
        .dock-icon.researching .icon-progress-fill {
            background: #22c55e; 
        }

        .icon-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ef4444;
            color: white;
            font-size: 10px;
            font-weight: bold;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 2px black;
        }

        .icon-badge.house-badge {
            background: #eab308;
            color: #000;
        }

        /* Popover Menu */
        .popover-menu {
            position: absolute;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid #4b5563;
            border-radius: 8px;
            padding: 10px;
            min-width: 180px;
            display: none;
            flex-direction: column;
            gap: 8px;
            z-index: 60;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(12px);
        }

        .popover-menu::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
            width: 12px;
            height: 12px;
            background: rgba(31, 41, 55, 0.95);
            border-right: 1px solid #4b5563;
            border-bottom: 1px solid #4b5563;
        }

        .popover-title {
            font-size: 0.8rem;
            color: #9ca3af;
            text-transform: uppercase;
            border-bottom: 1px solid #4b5563;
            padding-bottom: 4px;
            margin-bottom: 4px;
            text-align: center;
        }

        .menu-btn {
            background: #374151;
            border: 1px solid #4b5563;
            color: white;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            transition: all 0.1s;
        }

        .menu-btn:hover:not(:disabled) {
            background: #4b5563;
        }

        .menu-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .btn-icon {
            font-size: 1.4rem;
        }

        .btn-info {
            display: flex;
            flex-direction: column;
            line-height: 1.2;
            text-align: left;
        }

        .btn-cost {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        .menu-btn.tech-btn {
            border-color: #8b5cf6;
            background: rgba(139, 92, 246, 0.1);
        }

        .menu-btn.tech-btn:hover:not(:disabled) {
            background: rgba(139, 92, 246, 0.3);
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            display: none;
        }

        .floater {
            position: absolute;
            color: white;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 1px 1px 2px black;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-30px);
                opacity: 0;
            }
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }
    </style>
</head>

<body>

    <div id="toast-container" class="fixed top-4 left-1/2 transform -translate-x-1/2 z-50"></div>

    <div class="top-bar">
        <div class="top-group">
            <div class="top-item text-blue">ç©å®¶</div>
            <div class="tech-status text-blue-light">
                <span id="p-tech-atk">ğŸ—¡ï¸ 0</span> 
                <span id="p-tech-def" class="ml-2">ğŸ›¡ï¸ 0</span>
            </div>
        </div>
        
        <div class="top-group right">
            <div class="top-item text-red">ç”µè„‘</div>
            <div class="tech-status text-red-light">
                <span id="e-tech-atk">ğŸ—¡ï¸ 0</span> 
                <span id="e-tech-def" class="ml-2">ğŸ›¡ï¸ 0</span>
            </div>
        </div>
    </div>

    <div id="game-wrapper">
        <div class="tactics-bar">
            <button id="btn-stance-defend" class="tactic-btn" onclick="game.setPlayerStance('defend')">ğŸ›¡ï¸ é˜²å®ˆ</button>
            <button id="btn-stance-hold" class="tactic-btn" onclick="game.setPlayerStance('hold')">âœ‹ å¾…å‘½</button>
            <button id="btn-stance-attack" class="tactic-btn active" onclick="game.setPlayerStance('attack')">âš”ï¸
                è¿›æ”»</button>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="p-base" class="base base-player">
            <div class="turret-addon"></div>
            <div>åŸºåœ°</div>
            <div class="hp-bar-bg">
                <div id="p-base-hp" class="hp-bar-fill"></div>
            </div>
        </div>
        <div id="e-base" class="base base-enemy">
            <div class="turret-addon"></div>
            <div>ç”µè„‘</div>
            <div class="hp-bar-bg">
                <div id="e-base-hp" class="hp-bar-fill"></div>
            </div>
        </div>
    </div>

    <div id="ui-layer">
        <div class="resource-widget">
            <div class="status-header">
                <div class="status-group" title="äººå£">
                    <span class="icon-house">ğŸ </span> <span id="disp-pop" class="pop-text">0/200</span>
                </div>
                <div class="status-group" title="ç©ºé—²å†œæ°‘">
                    <span class="icon-sleep">ğŸ’¤</span> <span id="disp-idle" class="idle-text">0</span>
                </div>
            </div>
            <div class="res-grid">
                <div class="res-icon">ğŸ¥©</div>
                <div class="res-val" id="res-stock-food">0</div>
                <div class="tiny-btn" id="sub-food" onclick="game.modWork('food',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">ğŸ‘¤</span><span class="res-w-val"
                        id="res-workers-food">0</span></div>
                <div class="tiny-btn" id="add-food" onclick="game.modWork('food',1)">+</div>

                <div class="res-icon">ğŸŒ²</div>
                <div class="res-val" id="res-stock-wood">0</div>
                <div class="tiny-btn" id="sub-wood" onclick="game.modWork('wood',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">ğŸ‘¤</span><span class="res-w-val"
                        id="res-workers-wood">0</span></div>
                <div class="tiny-btn" id="add-wood" onclick="game.modWork('wood',1)">+</div>

                <div class="res-icon">ğŸª™</div>
                <div class="res-val" id="res-stock-gold">0</div>
                <div class="tiny-btn" id="sub-gold" onclick="game.modWork('gold',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">ğŸ‘¤</span><span class="res-w-val"
                        id="res-workers-gold">0</span></div>
                <div class="tiny-btn" id="add-gold" onclick="game.modWork('gold',1)">+</div>

                <div class="res-icon">ğŸª¨</div>
                <div class="res-val" id="res-stock-stone">0</div>
                <div class="tiny-btn" id="sub-stone" onclick="game.modWork('stone',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">ğŸ‘¤</span><span class="res-w-val"
                        id="res-workers-stone">0</span></div>
                <div class="tiny-btn" id="add-stone" onclick="game.modWork('stone',1)">+</div>
            </div>
        </div>

        <div class="dock-container" id="dock">
            <div class="dock-icon build-icon" id="dock-build_menu" onclick="game.toggleDockItem('build_menu')">
                ğŸ”¨
            </div>
        </div>

        <div id="popover-container" class="popover-menu"></div>
    </div>

    <div id="game-over">
        <h1 id="end-title" class="text-5xl font-bold mb-4 text-white">GAME OVER</h1>
        <p id="end-reason" class="text-xl text-gray-300 mb-8">Reason</p>
        <button onclick="location.reload()"
            class="px-6 py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded">å†æ¥ä¸€å±€</button>
    </div>

    <script>
        const TICK_RATE = 100;
        const MAX_QUEUE_SIZE = 5;
        const MAX_TOTAL_POP = 200;

        const CONSTANTS = {
            INITIAL_RES: { food: 200, wood: 100, gold: 100, stone: 0 }, // é‡‘çŸ¿å®šä½1000
            BASE_HP: 2000, INITIAL_POP_CAP: 10,
            MAP_WIDTH_PERCENT: 100,
            UNIT_SIZE_PERCENT: 0.8,
            ATTACK_RANGE_PERCENT: 8,
            UNITS: {
                worker: { cost: { food: 50, wood: 0 }, time: 120, hp: 10, dmg: 0, def: 0, type: 'eco', label: 'å†œæ°‘' },
                clubman: { cost: { food: 80, wood: 20 }, time: 50, hp: 60, dmg: 5, def: 0, speed: 1.0, type: 'mil', label: 'æ£’å­å…µ' }
            },
            BUILDINGS: {
                house: { cost: { food: 0, wood: 50, stone: 0 }, pop: 10, time: 100, label: 'æˆ¿å±‹', icon: 'ğŸ ' },
                barracks: { cost: { food: 0, wood: 150, stone: 0 }, time: 200, label: 'å…µè¥', icon: 'âš”ï¸' },
                towncenter: { cost: { food: 0, wood: 0, stone: 350 }, pop: 10, time: 400, label: 'åŸºåœ°', icon: 'ğŸ›ï¸' },
                // æ–°å¢é“åŒ é“º
                blacksmith: { cost: { food: 0, wood: 150, stone: 0 }, time: 300, label: 'é“åŒ é“º', icon: 'âš’ï¸' }
            },
            TECHS: {
                turret_tech: { cost: { food: 0, wood: 0, gold: 100, stone: 50 }, time: 240, label: 'é˜²å¾¡ç‚®å°', icon: 'ğŸ¯', desc: 'åŸºåœ°è·å¾—å¼ºå¤§é˜²å¾¡åŠ›' },
                // é“åŒ é“ºç§‘æŠ€ï¼šæ”»å‡»
                tech_atk_1: { cost: { food: 0, wood: 100, gold: 150, stone: 0 }, time: 500, label: 'è¿‘æˆ˜æ”»å‡» I', icon: 'ğŸ—¡ï¸', level: 1, type: 'atk' },
                tech_atk_2: { cost: { food: 0, wood: 200, gold: 400, stone: 0 }, time: 1000, label: 'è¿‘æˆ˜æ”»å‡» II', icon: 'ğŸ—¡ï¸', level: 2, type: 'atk' },
                // ä¸‰çº§æ”»å‡»ï¼šæ¶ˆè€—ç¿»å€ï¼Œæ—¶é—´ç¿»å€ (2000 ticks = 200s)
                tech_atk_3: { cost: { food: 0, wood: 400, gold: 1000, stone: 0 }, time: 2000, label: 'è¿‘æˆ˜æ”»å‡» III', icon: 'ğŸ—¡ï¸', level: 3, type: 'atk' },
                
                // é“åŒ é“ºç§‘æŠ€ï¼šé˜²å¾¡
                tech_def_1: { cost: { food: 100, wood: 0, gold: 150, stone: 0 }, time: 500, label: 'è¿‘æˆ˜é˜²å¾¡ I', icon: 'ğŸ›¡ï¸', level: 1, type: 'def' },
                tech_def_2: { cost: { food: 200, wood: 0, gold: 400, stone: 0 }, time: 1000, label: 'è¿‘æˆ˜é˜²å¾¡ II', icon: 'ğŸ›¡ï¸', level: 2, type: 'def' },
                // ä¸‰çº§é˜²å¾¡ï¼šæ¶ˆè€—ç¿»å€ï¼Œæ—¶é—´ç¿»å€
                tech_def_3: { cost: { food: 400, wood: 0, gold: 1000, stone: 0 }, time: 2000, label: 'è¿‘æˆ˜é˜²å¾¡ III', icon: 'ğŸ›¡ï¸', level: 3, type: 'def' }
            }
        };

        class Entity {
            constructor(type, owner, id) {
                this.id = id; this.type = type; this.owner = owner;
                const uData = CONSTANTS.UNITS[type];
                this.maxHp = uData.hp; 
                this.hp = this.maxHp;
                
                // åŸºç¡€å±æ€§
                this.dmg = uData.dmg || 0;
                this.def = uData.def || 0;
                
                this.speed = (uData.speed || 0) / (1000 / TICK_RATE);
                this.pos = owner === 'player' ? 5 : 95; this.state = 'move';
                this.width = CONSTANTS.UNIT_SIZE_PERCENT;
                this.attackCooldown = Math.floor(Math.random() * 10); this.attackAnimTimer = 0;
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.lastTick = 0; this.entityIdCounter = 0; this.buildingIdCounter = 0; this.constructionIdCounter = 0; this.gameOver = false;

                this.state = {
                    tick: 0,
                    player: this.createFactionState('player'),
                    enemy: this.createFactionState('enemy'),
                    units: [],
                    playerStance: 'attack',
                    enemyStance: 'attack',
                    selectedDockId: null,
                    turretShots: []
                };

                window.addEventListener('click', (e) => {
                    if (!e.target.closest('.dock-icon') && !e.target.closest('.popover-menu')) this.closePopover();
                });

                this.renderDock();
                this.logicInterval = setInterval(() => this.updateLogic(), TICK_RATE);
                setInterval(() => this.debugAI(), 3000);
                requestAnimationFrame(() => this.loop());
            }

            debugAI() {
                if (this.gameOver) return;
                const ai = this.state.enemy;
                
                // ç»Ÿè®¡å»ºç­‘æ•°é‡
                const countBuilt = (t) => ai.buildingInstances.filter(b => b.type === t).length;
                const countConst = (t) => ai.constructions.filter(c => c.type === t).length;
                const barracksCount = countBuilt('barracks') + countConst('barracks');
                const blacksmithCount = countBuilt('blacksmith') + countConst('blacksmith');
                
                // æ ¼å¼åŒ–è¾“å‡º
                console.groupCollapsed(`ğŸ¤– AI çŠ¶æ€ç›‘æ§ (Tick: ${this.state.tick})`);
                
                // 1. èµ„æºçŠ¶å†µ
                console.log(`ğŸ’° èµ„æºåº“å­˜: [è‚‰: ${Math.floor(ai.food)}] [æœ¨: ${Math.floor(ai.wood)}] [é‡‘: ${Math.floor(ai.gold)}] [çŸ³: ${Math.floor(ai.stone)}]`);
                
                // 1.5 å†œæ°‘åˆ†é…
                console.log(`ğŸ‘·â€â™‚ï¸ å†œæ°‘åˆ†é…: [è‚‰: ${ai.assignments.food}] [æœ¨: ${ai.assignments.wood}] [é‡‘: ${ai.assignments.gold}] [çŸ³: ${ai.assignments.stone}] [ç©ºé—²: ${ai.idleWorkers}]`);

                // 2. é‡‡é›†é€»è¾‘åˆ¤æ–­
                const resources = [
                    { type: 'food', amount: ai.food },
                    { type: 'wood', amount: ai.wood },
                    { type: 'gold', amount: ai.gold }
                ];
                resources.sort((a, b) => a.amount - b.amount);
                console.log(`â›ï¸ å½“å‰å…¨åŠ›é‡‡é›†: %c${resources[0].type.toUpperCase()}`, 'color: orange; font-weight: bold', `(å› ä¸ºåº“å­˜æœ€å°‘)`);

                // 3. ç§‘æŠ€ä¸å…µåŠ›é—¨æ§› (æ”¹ä¸º12)
                const techReadyColor = ai.armyCount > 12 ? 'green' : 'red';
                console.log(`âš”ï¸ å†›é˜Ÿæ•°é‡: %c${ai.armyCount}/12`, `color: ${techReadyColor}; font-weight: bold`, 
                            ai.armyCount > 12 ? 'âœ… å·²æ»¡è¶³ç§‘æŠ€ç ”å‘é—¨æ§›' : 'âŒ æœªè¾¾æ ‡ï¼Œä¼˜å…ˆæš´å…µ');
                
                // 4. å»ºç­‘çŠ¶å†µ
                const bsColor = blacksmithCount > 0 ? 'green' : 'red';
                console.log(`ğŸ—ï¸ å…³é”®å»ºç­‘: å…µè¥ x${barracksCount}, %cé“åŒ é“º x${blacksmithCount}`, `color: ${bsColor}`);
                
                // 5. ç§‘æŠ€ç­‰çº§
                console.log(`ğŸ“ å½“å‰ç§‘æŠ€: æ”»[${ai.techLevels.atk}] é˜²[${ai.techLevels.def}]`);

                // 6. æ­£åœ¨åšä»€ä¹ˆ
                const blacksmith = ai.buildingInstances.find(b => b.type === 'blacksmith');
                if (blacksmith && blacksmith.queue.length > 0) {
                    console.log(`ğŸ”¥ %cæ­£åœ¨ç ”å‘: ${CONSTANTS.TECHS[blacksmith.queue[0].type].label}`, 'color: #f0f; font-weight: bold');
                } else if (ai.armyCount > 12 && blacksmithCount > 0) {
                    console.log(`ğŸ’¤ é“åŒ é“ºå¾…æœºä¸­ (å¯èƒ½èµ„æºä¸è¶³)`);
                }

                console.groupEnd();
            }

            createFactionState(name) {
                const initialBuildings = [{ id: `${name}-b-${this.buildingIdCounter++}`, type: 'towncenter', queue: [] }];
                let initialWorkers = 6;
                if (name === 'enemy') initialWorkers = 9;
                return {
                    name: name,
                    food: CONSTANTS.INITIAL_RES.food, wood: CONSTANTS.INITIAL_RES.wood, gold: CONSTANTS.INITIAL_RES.gold, stone: CONSTANTS.INITIAL_RES.stone,
                    idleWorkers: 0, assignments: { food: initialWorkers, wood: 0, gold: 0, stone: 0 }, workers: initialWorkers,
                    popCap: CONSTANTS.INITIAL_POP_CAP, baseHp: CONSTANTS.BASE_HP,
                    buildingInstances: initialBuildings, constructions: [], armyCount: 0,
                    hasTurret: false, turretCooldown: 0,
                    // æ–°å¢ï¼šç§‘æŠ€ç­‰çº§è®°å½•
                    techLevels: { atk: 0, def: 0 }
                };
            }

            resizeCanvas() {
                const wrapper = document.getElementById('game-wrapper');
                this.canvas.width = wrapper.offsetWidth; this.canvas.height = wrapper.offsetHeight;
            }

            toggleDockItem(id) {
                if (this.state.selectedDockId === id) this.closePopover();
                else { this.state.selectedDockId = id; this.buildPopover(); this.updateDockVisuals(); }
            }
            closePopover() {
                this.state.selectedDockId = null;
                document.getElementById('popover-container').style.display = 'none';
                this.updateDockVisuals();
            }

            modWork(type, change) {
                const p = this.state.player;
                if (change > 0) {
                    if (p.idleWorkers > 0) { p.idleWorkers--; p.assignments[type]++; }
                    else this.showToast("æ²¡æœ‰ç©ºé—²å†œæ°‘");
                } else {
                    if (p.assignments[type] > 0) { p.assignments[type]--; p.idleWorkers++; }
                }
            }

            updateLogic() {
                if (this.gameOver) return;
                this.state.tick++;
                if (this.state.tick % 10 === 0) {
                    this.gatherResources(this.state.player);
                    this.gatherResources(this.state.enemy);
                    this.runAI();
                }
                this.processBuildingQueues(this.state.player); this.processBuildingQueues(this.state.enemy);
                this.processConstructions(this.state.player); this.processConstructions(this.state.enemy);

                this.state.turretShots = [];
                this.processBaseDefense(this.state.player);
                this.processBaseDefense(this.state.enemy);

                this.updateUnits();
                this.updateUI();
            }

            gatherResources(f) {
                f.food += f.assignments.food; f.wood += f.assignments.wood;
                f.gold += f.assignments.gold; f.stone += f.assignments.stone;
            }

            processBuildingQueues(f) {
                f.buildingInstances.forEach(b => {
                    if (b.queue.length > 0) {
                        b.queue[0].ticksLeft--;
                        if (b.queue[0].ticksLeft <= 0) {
                            const item = b.queue[0];
                            // å¤„ç†ç§‘æŠ€å®Œæˆ
                            if (CONSTANTS.TECHS[item.type]) {
                                const tech = CONSTANTS.TECHS[item.type];
                                if (item.type === 'turret_tech') {
                                    f.hasTurret = true;
                                    if (f.name === 'player') this.showToast("ç‚®å°ç³»ç»Ÿå‡çº§å®Œæˆ!", "#8b5cf6");
                                } 
                                else if (tech.type === 'atk' || tech.type === 'def') {
                                    // å‡çº§ æ”»å‡» æˆ– é˜²å¾¡
                                    f.techLevels[tech.type] = tech.level;
                                    if (f.name === 'player') this.showToast(`${tech.label} ç ”å‘å®Œæˆ!`, "#8b5cf6");
                                    
                                    // ç«‹å³æ›´æ–°å…¨åœºç°æœ‰å…µç§å±æ€§
                                    this.state.units.filter(u => u.owner === f.name && CONSTANTS.UNITS[u.type].type === 'mil').forEach(u => {
                                        if(tech.type === 'atk') u.dmg += 1;
                                        if(tech.type === 'def') u.def += 1;
                                    });
                                }
                                // å¦‚æœå½“å‰æ­£åœ¨çœ‹è¿™ä¸ªå»ºç­‘ï¼Œåˆ·æ–°èœå•ä»¥æ˜¾ç¤ºä¸‹ä¸€çº§ç§‘æŠ€
                                if(this.state.selectedDockId === b.id) this.buildPopover();
                                else this.closePopover();
                            } else {
                                this.spawnUnit(f, item.type);
                            }
                            b.queue.shift();
                        }
                    }
                });
            }

            processBaseDefense(f) {
                if (!f.hasTurret) return;
                if (f.turretCooldown > 0) { f.turretCooldown--; return; }
                const RANGE = CONSTANTS.ATTACK_RANGE_PERCENT * 2;
                const DAMAGE = CONSTANTS.UNITS.clubman.dmg * 1.5;
                const COOLDOWN = Math.floor(10 / 1.25);
                const basePos = f.name === 'player' ? 0 : 100;
                const enemies = this.state.units.filter(u => u.owner !== f.name);
                const targets = enemies.filter(e => Math.abs(e.pos - basePos) <= RANGE);
                if (targets.length > 0) {
                    f.turretCooldown = COOLDOWN;
                    const shotCount = Math.min(targets.length, 3);
                    for (let i = 0; i < shotCount; i++) {
                        const target = targets[Math.floor(Math.random() * targets.length)];
                        // åŸºåœ°ç‚®å°ä¼¤å®³ä¹Ÿå—é˜²å¾¡åŠ›å‡å…
                        let actualDmg = Math.max(1, DAMAGE - target.def); 
                        target.hp -= actualDmg;
                        this.spawnFloater(target.pos, `-${actualDmg.toFixed(1)}`, '#f0f');
                        this.state.turretShots.push({ start: basePos, end: target.pos, color: f.name === 'player' ? '#60a5fa' : '#f87171' });
                    }
                }
            }

            processConstructions(f) {
                const activeConstructions = [];
                let shouldRebuildDock = false;
                f.constructions.forEach(task => {
                    task.ticksLeft--;
                    if (task.ticksLeft <= 0) {
                        if (task.type === 'house' || task.type === 'towncenter') f.popCap = Math.min(f.popCap + (CONSTANTS.BUILDINGS[task.type].pop || 0), MAX_TOTAL_POP);
                        f.buildingInstances.push({ id: `${f.name}-b-${this.buildingIdCounter++}`, type: task.type, queue: [] });
                        if (f.name === 'player') { this.showToast(`${CONSTANTS.BUILDINGS[task.type].label} å»ºé€ å®Œæˆ`, '#22c55e'); shouldRebuildDock = true; }
                    } else { activeConstructions.push(task); }
                });
                f.constructions = activeConstructions;
                if (shouldRebuildDock) { this.closePopover(); this.renderDock(); }
            }

            spawnUnit(f, type) {
                if (f.name !== 'enemy' && f.workers + f.armyCount >= MAX_TOTAL_POP) return;
                if (CONSTANTS.UNITS[type].type === 'eco') { f.workers++; f.idleWorkers++; }
                else { 
                    f.armyCount++; 
                    const u = new Entity(type, f.name, this.entityIdCounter++);
                    // åˆå§‹å±æ€§ + ç§‘æŠ€åŠ æˆ
                    if (CONSTANTS.UNITS[type].type === 'mil') {
                        u.dmg += f.techLevels.atk;
                        u.def += f.techLevels.def;
                    }
                    this.state.units.push(u);
                }
            }

            playerQueueUnit(bid, type) {
                const f = this.state.player; const b = f.buildingInstances.find(i => i.id === bid);
                if (!b) return;
                const unitData = CONSTANTS.UNITS[type];
                if (b.queue.length >= MAX_QUEUE_SIZE) { this.showToast("é˜Ÿåˆ—å·²æ»¡"); return; }
                let totalPop = f.workers + f.armyCount; f.buildingInstances.forEach(bb => totalPop += bb.queue.length);
                if (totalPop >= MAX_TOTAL_POP || totalPop >= f.popCap) { this.showToast("äººå£ä¸è¶³"); return; }
                if (f.food < unitData.cost.food || f.wood < unitData.cost.wood) { this.showToast("èµ„æºä¸è¶³"); return; }
                f.food -= unitData.cost.food; f.wood -= unitData.cost.wood;
                b.queue.push({ type: type, ticksLeft: unitData.time, totalTicks: unitData.time });
                this.refreshPopoverState();
            }

            playerQueueTech(bid, techId) {
                const f = this.state.player; const b = f.buildingInstances.find(i => i.id === bid);
                if (!b) return;
                const tech = CONSTANTS.TECHS[techId];
                if (b.queue.length > 0) { this.showToast("é˜Ÿåˆ—ä¸ä¸ºç©º"); return; }
                if (f.food < tech.cost.food || f.wood < tech.cost.wood || f.gold < tech.cost.gold || f.stone < tech.cost.stone) { this.showToast("èµ„æºä¸è¶³"); return; }
                
                f.food -= (tech.cost.food || 0);
                f.wood -= (tech.cost.wood || 0);
                f.gold -= (tech.cost.gold || 0);
                f.stone -= (tech.cost.stone || 0);

                b.queue.push({ type: techId, ticksLeft: tech.time, totalTicks: tech.time });
                this.showToast("ç ”å‘: " + tech.label, "#8b5cf6");
                this.closePopover(); // åˆ·æ–°æˆ–å…³é—­
            }

            playerBuildStructure(type) {
                const f = this.state.player; const d = CONSTANTS.BUILDINGS[type];
                if (type === 'house' && f.popCap >= MAX_TOTAL_POP) { this.showToast("äººå£å·²è¾¾ä¸Šé™"); return; }
                const sCost = d.cost.stone || 0;
                if (f.food < d.cost.food || f.wood < d.cost.wood || f.stone < sCost) { this.showToast("èµ„æºä¸è¶³"); return; }
                f.food -= d.cost.food; f.wood -= d.cost.wood; f.stone -= sCost;
                f.constructions.push({ id: this.constructionIdCounter++, type: type, ticksLeft: d.time, totalTicks: d.time });
                this.showToast(`å¼€å§‹å»ºé€  ${d.label}`);
                this.closePopover(); this.renderDock();
            }

            setPlayerStance(s) {
                this.state.playerStance = s;
                ['defend', 'hold', 'attack'].forEach(k => {
                    const b = document.getElementById(`btn-stance-${k}`);
                    b.className = `tactic-btn ${k === s ? 'active' : ''} ${k === s && k === 'defend' ? 'active-defend' : ''} ${k === s && k === 'hold' ? 'active-hold' : ''}`;
                });
            }

            runAI() {
                const ai = this.state.enemy;
                // 1. èµ„æºç®¡ç† 
                ai.assignments = { food: 0, wood: 0, gold: 0, stone: 0 };
                ai.idleWorkers = 0; 
                
                const resources = [
                    { type: 'food', amount: ai.food },
                    { type: 'wood', amount: ai.wood },
                    { type: 'gold', amount: ai.gold }
                ];
                resources.sort((a, b) => a.amount - b.amount);
                ai.assignments[resources[0].type] = ai.workers;

                // 2. ç§‘æŠ€ç ”å‘å†³ç­–
                let savingForTech = false;
                const blacksmith = ai.buildingInstances.find(b => b.type === 'blacksmith');
                
                // æ”¹åŠ¨ï¼šé˜ˆå€¼ä»30é™åˆ°12
                if (ai.armyCount > 12 && blacksmith && blacksmith.queue.length === 0) {
                    const levels = ai.techLevels;
                    let targetTech = null;

                    if (levels.atk < 1) targetTech = 'tech_atk_1';
                    else if (levels.def < 1) targetTech = 'tech_def_1';
                    else if (levels.atk < 2) targetTech = 'tech_atk_2';
                    else if (levels.def < 2) targetTech = 'tech_def_2';
                    else if (levels.atk < 3) targetTech = 'tech_atk_3'; // ä¸‰çº§
                    else if (levels.def < 3) targetTech = 'tech_def_3'; // ä¸‰çº§

                    if (targetTech) {
                        const techData = CONSTANTS.TECHS[targetTech];
                        const costF = techData.cost.food || 0;
                        const costW = techData.cost.wood || 0;
                        const costG = techData.cost.gold || 0;
                        const costS = techData.cost.stone || 0;

                        if (ai.food >= costF && ai.wood >= costW && ai.gold >= costG && ai.stone >= costS) {
                            ai.food -= costF; ai.wood -= costW; ai.gold -= costG; ai.stone -= costS;
                            blacksmith.queue.push({ type: targetTech, ticksLeft: techData.time, totalTicks: techData.time });
                        } else {
                            savingForTech = true;
                        }
                    }
                }

                // 3. ç”Ÿäº§ç®¡ç†
                if (!savingForTech) {
                    let pendingWorkers = 0;
                    ai.buildingInstances.forEach(b => { b.queue.forEach(q => { if (q.type === 'worker') pendingWorkers++; }); });

                    const buildings = [...ai.buildingInstances].sort((a, b) => a.type === 'towncenter' ? -1 : 1);
                    buildings.forEach(b => {
                        if (b.queue.length < 5) { 
                            if (b.type === 'towncenter') { 
                                if (ai.workers + pendingWorkers < 60) {
                                    this.aiQueue(ai, b, 'worker'); pendingWorkers++;
                                }
                            } else if (b.type === 'barracks') { 
                                this.aiQueue(ai, b, 'clubman'); 
                            }
                        }
                    });
                }

                // 4. å»ºç­‘è§„åˆ’
                const countType = (t) => {
                    const built = ai.buildingInstances.filter(b => b.type === t).length;
                    const constructing = ai.constructions.filter(c => c.type === t).length;
                    return built + constructing;
                };
                
                let structureToBuild = null;
                const numBarracks = countType('barracks');
                const numBlacksmith = countType('blacksmith');

                // ä¿®å¤åçš„é€»è¾‘ï¼š
                // 1. å¿…é¡»å…ˆé€  1 ä¸ªå…µè¥
                if (numBarracks < 1) {
                    structureToBuild = 'barracks';
                } 
                // 2. ç„¶åå¿…é¡»é€  1 ä¸ªé“åŒ é“º
                else if (numBlacksmith < 1) {
                    structureToBuild = 'blacksmith';
                } 
                // 3. ã€ä¿®å¤ã€‘åªæœ‰å½“å…µè¥å°‘äº 5 ä¸ªæ—¶ï¼Œæ‰ç»§ç»­è¡¥å……å…µè¥
                //    è¿™æ · AI å°±ä¸ä¼šæ— é™å»ºé€ ï¼Œèƒ½çœä¸‹èµ„æºå»é€ å…µæˆ–å‡çº§
                else if (numBarracks < 6 || ai.wood > 600) {
                    structureToBuild = 'barracks';
                }
                // ...
                
                if (structureToBuild) {
                    const d = CONSTANTS.BUILDINGS[structureToBuild];
                    const cF = d.cost.food || 0;
                    const cW = d.cost.wood || 0;
                    const cS = d.cost.stone || 0;
                    if (ai.food >= cF && ai.wood >= cW && ai.stone >= cS) {
                        this.aiBuild(ai, structureToBuild);
                    }
                }

                // 5. æˆ˜æœ¯å§¿æ€
                const pUnits = this.state.units.filter(u => u.owner === 'player');
                const eUnits = this.state.units.filter(u => u.owner === 'enemy');
                
                let playerFront = 0; 
                if (pUnits.length > 0) playerFront = Math.max(...pUnits.map(u => u.pos));
                let enemyFront = 100; 
                if (eUnits.length > 0) enemyFront = Math.min(...eUnits.map(u => u.pos));

                const distance = enemyFront - playerFront;
                const battleLine = (playerFront + enemyFront) / 2;

                let newStance = 'attack'; 
                if (distance > 30) {
                    newStance = 'attack';
                } else {
                    if (battleLine > 65) {
                        newStance = 'defend';
                    } else {
                        newStance = 'attack';
                    }
                }
                if (this.state.enemyStance !== newStance) {
                    this.state.enemyStance = newStance;
                }
            }
            
            aiBuild(f, t) {
                const d = CONSTANTS.BUILDINGS[t]; const s = d.cost.stone || 0;
                if (f.food >= d.cost.food && f.wood >= d.cost.wood && f.stone >= s) {
                    f.food -= d.cost.food; f.wood -= d.cost.wood; f.stone -= s;
                    f.constructions.push({ id: Math.random(), type: t, ticksLeft: d.time, totalTicks: d.time });
                }
            }

            aiQueue(f, b, u) {
                const d = CONSTANTS.UNITS[u];
                if (f.food >= d.cost.food && f.wood >= d.cost.wood) {
                    f.food -= d.cost.food; f.wood -= d.cost.wood;
                    b.queue.push({ type: u, ticksLeft: d.time, totalTicks: d.time });
                }
            }

            updateUI() {
                const p = this.state.player; const e = this.state.enemy;
                document.getElementById('p-base-hp').style.width = Math.max(0, (p.baseHp / CONSTANTS.BASE_HP * 100)) + '%';
                document.getElementById('e-base-hp').style.width = Math.max(0, (e.baseHp / CONSTANTS.BASE_HP * 100)) + '%';

                if (p.hasTurret) document.getElementById('p-base').classList.add('has-turret');
                if (e.hasTurret) document.getElementById('e-base').classList.add('has-turret');
                
                // æ›´æ–°ç§‘æŠ€æ˜¾ç¤º
                const toRoman = (n) => n === 0 ? '0' : (n === 1 ? 'I' : (n === 2 ? 'II' : 'III'));
                document.getElementById('p-tech-atk').innerText = `ğŸ—¡ï¸ ${toRoman(p.techLevels.atk)}`;
                document.getElementById('p-tech-def').innerText = `ğŸ›¡ï¸ ${toRoman(p.techLevels.def)}`;
                document.getElementById('e-tech-atk').innerText = `ğŸ—¡ï¸ ${toRoman(e.techLevels.atk)}`;
                document.getElementById('e-tech-def').innerText = `ğŸ›¡ï¸ ${toRoman(e.techLevels.def)}`;

                const currentPop = p.workers + p.armyCount;
                const popEl = document.getElementById('disp-pop');
                popEl.innerText = `${currentPop}/${p.popCap}`;
                popEl.style.color = '#e5e5e5';
                if (currentPop >= p.popCap) popEl.style.color = '#ef4444';
                else if (currentPop >= p.popCap * 0.8) popEl.style.color = '#eab308';

                const idleEl = document.getElementById('disp-idle'); idleEl.innerText = p.idleWorkers;
                if (p.idleWorkers > 0) idleEl.classList.add('warning'); else idleEl.classList.remove('warning');

                ['food', 'wood', 'gold', 'stone'].forEach(r => {
                    document.getElementById(`res-stock-${r}`).innerText = Math.floor(p[r]);
                    document.getElementById(`res-workers-${r}`).innerText = p.assignments[r];
                    const btnAdd = document.getElementById(`add-${r}`);
                    const btnSub = document.getElementById(`sub-${r}`);
                    if (p.idleWorkers > 0) btnAdd.classList.remove('disabled'); else btnAdd.classList.add('disabled');
                    if (p.assignments[r] > 0) btnSub.classList.remove('disabled'); else btnSub.classList.add('disabled');
                });

                this.updateDockProgress();
                if (this.state.selectedDockId) this.refreshPopoverState();
            }

            renderDock() {
                const dock = document.getElementById('dock'); dock.innerHTML = ''; const p = this.state.player;
                const houses = p.buildingInstances.filter(b => b.type === 'house');
                
                // æ··åˆæ¸²æŸ“ï¼šå·²å»ºæˆçš„åŠŸèƒ½å»ºç­‘ + æ­£åœ¨å»ºé€ ä¸­çš„æ‰€æœ‰å»ºç­‘
                const builtBuildings = p.buildingInstances.filter(b => b.type !== 'house').map(b => ({...b, isConstruction: false}));
                const underConstruction = p.constructions.map(c => ({...c, isConstruction: true}));
                
                const mixedList = [...builtBuildings, ...underConstruction];
                
                // æ’åºé€»è¾‘ï¼šåŸºåœ° > å…µè¥ > é“åŒ é“º
                mixedList.sort((a, b) => {
                    const order = { towncenter: 1, barracks: 2, blacksmith: 3 };
                    return (order[a.type] || 99) - (order[b.type] || 99);
                });

                mixedList.forEach(item => {
                    if(item.isConstruction) {
                        const icon = this.createDockIcon(`const-${item.id}`, CONSTANTS.BUILDINGS[item.type].icon, true); 
                        dock.appendChild(icon);
                    } else {
                        const icon = this.createDockIcon(item.id, CONSTANTS.BUILDINGS[item.type].icon, false); 
                        icon.onclick = () => this.toggleDockItem(item.id); 
                        dock.appendChild(icon);
                    }
                });

                if (houses.length > 0) { const icon = this.createDockIcon('group-house', CONSTANTS.BUILDINGS['house'].icon, false); icon.onclick = () => this.toggleDockItem('group-house'); icon.querySelector('.icon-badge').style.display = 'flex'; icon.querySelector('.icon-badge').classList.add('house-badge'); icon.querySelector('.icon-badge').innerText = houses.length; dock.appendChild(icon); }
                
                const hammer = this.createDockIcon('dock-build_menu', 'ğŸ”¨', false); hammer.classList.add('build-icon'); hammer.onclick = () => this.toggleDockItem('build_menu'); dock.appendChild(hammer);
                this.updateDockVisuals();
            }

            createDockIcon(id, emoji, isConstructing) {
                const icon = document.createElement('div'); icon.className = `dock-icon ${isConstructing ? 'constructing' : ''}`;
                icon.id = `dock-elem-${id}`; icon.dataset.refId = id; icon.innerHTML = emoji;
                if (isConstructing) { const overlay = document.createElement('div'); overlay.className = 'const-overlay'; icon.appendChild(overlay); }
                const barBg = document.createElement('div'); barBg.className = 'icon-progress-bg'; const barFill = document.createElement('div'); barFill.className = 'icon-progress-fill'; barBg.appendChild(barFill); icon.appendChild(barBg);
                const badge = document.createElement('div'); badge.className = 'icon-badge'; badge.style.display = 'none'; icon.appendChild(badge);
                return icon;
            }

            updateDockProgress() {
                const p = this.state.player;
                p.buildingInstances.forEach(b => {
                    if (b.type === 'house') return;
                    const el = document.getElementById(`dock-elem-${b.id}`);
                    if (el) {
                        const barBg = el.querySelector('.icon-progress-bg'); const bar = el.querySelector('.icon-progress-fill'); const badge = el.querySelector('.icon-badge');
                        if (b.queue.length > 0) { 
                            const t = b.queue[0]; 
                            bar.style.width = (100 - (t.ticksLeft / t.totalTicks * 100)) + '%'; 
                            badge.style.display = 'flex'; badge.innerText = b.queue.length; barBg.style.display = 'block'; 
                            
                            if (CONSTANTS.TECHS[t.type]) {
                                el.classList.add('researching');
                            } else {
                                el.classList.remove('researching');
                            }

                        } else { 
                            bar.style.width = '0%'; badge.style.display = 'none'; barBg.style.display = 'none'; 
                            el.classList.remove('researching');
                        }
                    }
                });
                const houseCount = p.buildingInstances.filter(b => b.type === 'house').length;
                const hIcon = document.getElementById('dock-elem-group-house');
                if (hIcon) { hIcon.querySelector('.icon-badge').innerText = houseCount; if (hIcon.querySelector('.icon-progress-bg')) hIcon.querySelector('.icon-progress-bg').style.display = 'none'; }
                p.constructions.forEach(task => {
                    const el = document.getElementById(`dock-elem-const-${task.id}`);
                    if (el) {
                        const bar = el.querySelector('.icon-progress-fill'); const overlay = el.querySelector('.const-overlay');
                        const pct = Math.floor(100 - (task.ticksLeft / task.totalTicks * 100)); bar.style.width = pct + '%'; overlay.innerText = pct + '%'; el.querySelector('.icon-progress-bg').style.display = 'block';
                    }
                });
            }

            updateDockVisuals() {
                const dock = document.getElementById('dock');
                Array.from(dock.children).forEach(el => {
                    const logicalId = el.id === 'dock-elem-dock-build_menu' ? 'build_menu' : el.dataset.refId;
                    if (this.state.selectedDockId === logicalId) el.classList.add('active'); else el.classList.remove('active');
                });
            }

            buildPopover() {
                const container = document.getElementById('popover-container');
                const id = this.state.selectedDockId;
                if (!id) { container.style.display = 'none'; return; }
                container.innerHTML = ''; container.style.display = 'flex';
                const domId = id === 'build_menu' ? 'dock-elem-dock-build_menu' : `dock-elem-${id}`;
                const icon = document.getElementById(domId);
                if (icon) { const rect = icon.getBoundingClientRect(); container.style.left = (rect.left + rect.width / 2) + 'px'; }

                const p = this.state.player;
                if (id === 'build_menu') {
                    container.innerHTML = `<div class="popover-title">å»ºé€ </div>`;
                    ['house', 'barracks', 'blacksmith', 'towncenter'].forEach(t => {
                        const d = CONSTANTS.BUILDINGS[t];
                        const btn = document.createElement('div'); btn.className = 'menu-btn build-action-btn'; btn.dataset.type = t;
                        btn.onclick = () => this.playerBuildStructure(t);
                        let cost = []; 
                        if(d.cost.food) cost.push(`${d.cost.food}è‚‰`);
                        if(d.cost.wood) cost.push(`${d.cost.wood}æœ¨`); 
                        if(d.cost.stone) cost.push(`${d.cost.stone}çŸ³`);
                        btn.innerHTML = `<span class="btn-icon">${d.icon}</span><div class="btn-info"><span>${d.label}</span><span class="btn-cost">${cost.join(' ')}</span></div>`;
                        container.appendChild(btn);
                    });
                } else if (id === 'group-house') {
                    container.innerHTML = `<div class="popover-title">æˆ¿å±‹</div><div class="p-2 text-sm text-gray-300 text-center">æˆ¿å±‹ç”¨äºå¢åŠ äººå£</div>`;
                } else {
                    const b = p.buildingInstances.find(x => x.id === id);
                    if (b) {
                        const buildingLabel = CONSTANTS.BUILDINGS[b.type].label;
                        container.innerHTML = `<div class="popover-title">${buildingLabel}</div>`;
                        
                        if (b.queue.length > 0) {
                            const currentItem = b.queue[0];
                            let itemLabel = '';
                            let action = 'ç”Ÿäº§';
                            if (CONSTANTS.UNITS[currentItem.type]) {
                                itemLabel = CONSTANTS.UNITS[currentItem.type].label;
                            } else if (CONSTANTS.TECHS[currentItem.type]) {
                                itemLabel = CONSTANTS.TECHS[currentItem.type].label;
                                action = 'ç ”å‘';
                            }
                            
                            const statusDiv = document.createElement('div');
                            statusDiv.className = 'text-xs text-blue-400 text-center mb-2 font-bold';
                            const progress = Math.floor(100 - (currentItem.ticksLeft / currentItem.totalTicks * 100));
                            statusDiv.innerText = `æ­£åœ¨${action}: ${itemLabel} (${progress}%)`;
                            if (action === 'ç ”å‘') statusDiv.style.color = '#22c55e'; 
                            
                            container.appendChild(statusDiv);
                        }
                        
                        if (b.type === 'towncenter' || b.type === 'barracks') {
                            const uType = b.type === 'towncenter' ? 'worker' : 'clubman'; const u = CONSTANTS.UNITS[uType];
                            const btn = document.createElement('div'); btn.className = 'menu-btn produce-action-btn'; btn.dataset.type = uType;
                            btn.onclick = () => this.playerQueueUnit(id, uType);
                            let cost = []; if (u.cost.food) cost.push(`${u.cost.food}è‚‰`); if (u.cost.wood) cost.push(`${u.cost.wood}æœ¨`);
                            btn.innerHTML = `<span class="btn-icon">${uType === 'worker' ? 'ğŸ‘·' : 'âš”ï¸'}</span><div class="btn-info"><span>è®­ç»ƒ${u.label}</span><span class="btn-cost">${cost.join(' ')}</span></div>`;
                            container.appendChild(btn);
                        }

                        if (b.type === 'towncenter') {
                            const isQueuingTurret = p.buildingInstances.some(bi => bi.queue.some(q => q.type === 'turret_tech'));
                            if (!p.hasTurret && !isQueuingTurret) {
                                const tech = CONSTANTS.TECHS.turret_tech;
                                const techBtn = document.createElement('div'); techBtn.className = 'menu-btn tech-btn'; techBtn.dataset.tech = 'turret_tech';
                                techBtn.onclick = () => this.playerQueueTech(id, 'turret_tech');
                                let tCost = []; if (tech.cost.gold) tCost.push(`${tech.cost.gold}é‡‘`); if (tech.cost.stone) tCost.push(`${tech.cost.stone}çŸ³`);
                                techBtn.innerHTML = `<span class="btn-icon">${tech.icon}</span><div class="btn-info"><span>ç ”å‘${tech.label}</span><span class="btn-cost">${tCost.join(' ')}</span></div>`;
                                container.appendChild(techBtn);
                            }
                        }

                        if (b.type === 'blacksmith') {
                            const researchingAtk = p.buildingInstances.some(bi => bi.queue.some(q => q.type.startsWith('tech_atk')));
                            const researchingDef = p.buildingInstances.some(bi => bi.queue.some(q => q.type.startsWith('tech_def')));
                            const techLevels = p.techLevels;

                            if (techLevels.atk < 3 && !researchingAtk) {
                                const nextLvl = techLevels.atk + 1;
                                const techId = `tech_atk_${nextLvl}`;
                                const tech = CONSTANTS.TECHS[techId];
                                const techBtn = document.createElement('div'); techBtn.className = 'menu-btn tech-btn'; techBtn.dataset.tech = techId;
                                techBtn.onclick = () => this.playerQueueTech(id, techId);
                                let tCost = []; 
                                if (tech.cost.wood) tCost.push(`${tech.cost.wood}æœ¨`);
                                if (tech.cost.food) tCost.push(`${tech.cost.food}è‚‰`);
                                if (tech.cost.gold) tCost.push(`${tech.cost.gold}é‡‘`);
                                techBtn.innerHTML = `<span class="btn-icon">${tech.icon}</span><div class="btn-info"><span>${tech.label}</span><span class="btn-cost">${tCost.join(' ')}</span></div>`;
                                container.appendChild(techBtn);
                            }

                            if (techLevels.def < 3 && !researchingDef) {
                                const nextLvl = techLevels.def + 1;
                                const techId = `tech_def_${nextLvl}`;
                                const tech = CONSTANTS.TECHS[techId];
                                const techBtn = document.createElement('div'); techBtn.className = 'menu-btn tech-btn'; techBtn.dataset.tech = techId;
                                techBtn.onclick = () => this.playerQueueTech(id, techId);
                                let tCost = []; 
                                if (tech.cost.wood) tCost.push(`${tech.cost.wood}æœ¨`);
                                if (tech.cost.food) tCost.push(`${tech.cost.food}è‚‰`);
                                if (tech.cost.gold) tCost.push(`${tech.cost.gold}é‡‘`);
                                techBtn.innerHTML = `<span class="btn-icon">${tech.icon}</span><div class="btn-info"><span>${tech.label}</span><span class="btn-cost">${tCost.join(' ')}</span></div>`;
                                container.appendChild(techBtn);
                            }
                            
                            if(techLevels.atk >= 3 && techLevels.def >= 3) {
                                container.innerHTML += `<div class="text-xs text-gray-400 text-center mt-2">ç§‘æŠ€å·²å‡è‡³é¡¶çº§</div>`;
                            }
                        }

                        const q = document.createElement('div'); q.id = 'popover-queue-info'; q.className = 'text-xs text-gray-400 text-center mt-1'; container.appendChild(q);
                    }
                }
                this.refreshPopoverState();
            }

            refreshPopoverState() {
                const id = this.state.selectedDockId; if (!id || id === 'group-house') return;
                const p = this.state.player;
                if (id === 'build_menu') {
                    document.querySelectorAll('.build-action-btn').forEach(btn => {
                        const t = btn.dataset.type; const d = CONSTANTS.BUILDINGS[t]; 
                        const s = d.cost.stone || 0; const f = d.cost.food || 0; const w = d.cost.wood || 0;
                        if (p.food >= f && p.wood >= w && p.stone >= s) btn.removeAttribute('disabled'); else btn.setAttribute('disabled', 'true');
                    });
                } else {
                    const b = p.buildingInstances.find(x => x.id === id);
                    if (!b) { this.closePopover(); return; }
                    document.querySelectorAll('.produce-action-btn').forEach(btn => {
                        const t = btn.dataset.type; const u = CONSTANTS.UNITS[t];
                        if (p.food >= u.cost.food && p.wood >= u.cost.wood) btn.removeAttribute('disabled'); else btn.setAttribute('disabled', 'true');
                    });
                    document.querySelectorAll('.tech-btn').forEach(btn => {
                        const tId = btn.dataset.tech; const t = CONSTANTS.TECHS[tId];
                        const f = t.cost.food || 0; const w = t.cost.wood || 0; const g = t.cost.gold || 0; const s = t.cost.stone || 0;
                        if (p.food >= f && p.wood >= w && p.gold >= g && p.stone >= s) btn.removeAttribute('disabled'); else btn.setAttribute('disabled', 'true');
                    });
                    const qInfo = document.getElementById('popover-queue-info'); if (qInfo) qInfo.innerText = `é˜Ÿåˆ—: ${b.queue.length}`;
                }
            }

            updateUnits() {
                let p = this.state.units.filter(u => u.owner === 'player'); let e = this.state.units.filter(u => u.owner === 'enemy').sort((a, b) => a.pos - b.pos);
                if (this.state.playerStance === 'attack') p.sort((a, b) => b.pos - a.pos); else p.sort((a, b) => a.pos - b.pos);
                p.forEach((u, i) => { this.processCombat(u, e, 1); this.processMovement(u, p, e, i, 1); });
                e.forEach((u, i) => { this.processCombat(u, p, -1); this.processMovement(u, e, p, i, -1); });
                const dead = this.state.units.filter(u => u.hp <= 0);
                dead.forEach(u => this.handleUnitDeath(u));
                this.state.units = this.state.units.filter(u => u.hp > 0);
                if (this.state.player.baseHp <= 0) this.endGame('DEFEAT', 'ä½ çš„å¸å›½é™·è½äº†ã€‚'); if (this.state.enemy.baseHp <= 0) this.endGame('VICTORY', 'ä½ å¾æœäº†é‡è›®äººï¼');
            }

            handleUnitDeath(u) {
                const f = u.owner === 'player' ? this.state.player : this.state.enemy;
                if (CONSTANTS.UNITS[u.type].type === 'eco') {
                    if (f.workers > 0) {
                        f.workers--;
                        if (f.idleWorkers > 0) f.idleWorkers--;
                        else {
                            for (const r of ['stone', 'gold', 'wood', 'food']) if (f.assignments[r] > 0) { f.assignments[r]--; break; }
                        }
                    }
                } else { f.armyCount = Math.max(0, f.armyCount - 1); }
            }

            processCombat(u, ens, dir) {
                if (u.attackAnimTimer > 0) u.attackAnimTimer--; if (u.attackCooldown > 0) u.attackCooldown--;
                let v = ens.filter(e => Math.abs(u.pos - e.pos) <= CONSTANTS.ATTACK_RANGE_PERCENT);
                let t = null;
                if (v.length > 0) t = v[Math.floor(Math.random() * v.length)];
                else if (Math.abs(u.pos - (dir === 1 ? 100 : 0)) <= CONSTANTS.ATTACK_RANGE_PERCENT) t = "base";
                if (t) {
                    u.state = 'attack'; u.targetId = (t === "base") ? "base" : t.id;
                    if (u.attackCooldown <= 0) {
                        u.attackCooldown = 10; u.attackAnimTimer = 3; const dmg = u.dmg;
                        if (t === "base") { 
                            // æ”»å‡»åŸºåœ°
                            if (u.owner === 'player') this.state.enemy.baseHp -= dmg; 
                            else this.state.player.baseHp -= dmg; 
                            this.spawnFloater(dir === 1 ? 95 : 5, `-${dmg}`, '#f00'); 
                        }
                        else { 
                            // æ”»å‡»å•ä½ï¼Œè®¡ç®—é˜²å¾¡å‡ä¼¤ï¼ˆæœ€å°‘1ç‚¹ä¼¤å®³ï¼‰
                            let actualDmg = Math.max(1, dmg - t.def);
                            t.hp -= actualDmg; 
                            this.spawnFloater(t.pos, `-${actualDmg}`, '#fff'); 
                        }
                    }
                } else { u.state = 'move'; }
            }

            processMovement(u, friends, enemies, i, dir) {
                let d = u.pos;
                const s = u.owner === 'player' ? this.state.playerStance : this.state.enemyStance;
                let speed = u.speed;
                if (dir === -1) speed = -speed;

                if (s === 'attack') {
                    d += speed;
                    if (i > 0) {
                        const l = friends[i - 1].pos - (dir * u.width);
                        if (dir === 1 ? d > l : d < l) d = l;
                    }
                    if (enemies.length > 0) {
                        const l = enemies[0].pos - (dir * u.width);
                        if (dir === 1 ? d > l : d < l) d = l;
                    } else if (dir === 1 ? d > 95 : d < 5) {
                        d = dir === 1 ? 95 : 5;
                    }
                } else {
                    if (s === 'defend') {
                        d -= speed;
                    }
                    if (dir === 1) {
                        let limit = 5;
                        if (i > 0) limit = friends[i - 1].pos + u.width;
                        if (d < limit) d = limit;
                    } else {
                        let limit = 95;
                        if (i < friends.length - 1) {
                             limit = friends[i+1].pos - u.width;
                        }
                        if (d > limit) d = limit;
                    }
                }
                u.pos = Math.min(100, Math.max(0, d));
            }

            spawnFloater(x, t, c) { const el = document.createElement('div'); el.className = 'floater'; const r = document.getElementById('game-wrapper').getBoundingClientRect(); el.style.left = (x / 100 * r.width) + 'px'; el.style.top = (r.height / 2 - 20) + 'px'; el.style.color = c; el.innerText = t; document.getElementById('game-wrapper').appendChild(el); setTimeout(() => el.remove(), 1000); }
            showToast(msg, c = '#ef4444') { const el = document.createElement('div'); el.className = 'toast text-white px-4 py-2 rounded shadow-lg font-bold'; el.style.background = c; el.innerText = msg; document.getElementById('toast-container').appendChild(el); setTimeout(() => el.remove(), 2000); }

            loop() { if (!this.gameOver) { this.draw(); requestAnimationFrame(() => this.loop()); } }

            draw() {
                const w = this.canvas.width; const h = this.canvas.height; this.ctx.clearRect(0, 0, w, h);
                this.ctx.strokeStyle = '#444'; this.ctx.beginPath(); this.ctx.moveTo(0, h / 2 + 20); this.ctx.lineTo(w, h / 2 + 20); this.ctx.stroke();

                this.state.turretShots.forEach(shot => {
                    this.ctx.strokeStyle = shot.color; this.ctx.lineWidth = 3; this.ctx.beginPath();
                    this.ctx.moveTo((shot.start / 100) * w, h / 2); this.ctx.lineTo((shot.end / 100) * w, h / 2); this.ctx.stroke();
                    this.ctx.fillStyle = 'white'; this.ctx.beginPath(); this.ctx.arc((shot.end / 100) * w, h / 2, 5, 0, Math.PI * 2); this.ctx.fill();
                });

                this.state.units.forEach(u => {
                    const x = (u.pos / 100) * w; const y = h / 2;
                    this.ctx.fillStyle = u.owner === 'player' ? '#3b82f6' : '#ef4444';
                    if (u.owner === 'player') { this.ctx.fillRect(x - 5, y - 20, 10, 20); this.ctx.fillStyle = '#ccc'; this.ctx.fillRect(x + 5, y - 15, 8, 2); }
                    else { this.ctx.beginPath(); this.ctx.arc(x, y - 10, 6, 0, Math.PI * 2); this.ctx.fill(); this.ctx.fillStyle = '#ccc'; this.ctx.fillRect(x - 12, y - 12, 8, 2); }
                    if (u.attackAnimTimer > 0) {
                        this.ctx.strokeStyle = '#ffff00'; this.ctx.lineWidth = 2; this.ctx.beginPath();
                        this.ctx.moveTo(u.owner === 'player' ? x + 5 : x - 5, y - 15 + (Math.random() * 6 - 3));
                        let tx = u.owner === 'player' ? x + 30 : x - 30; let ty = y - 10;
                        if (u.targetId === "base") tx = u.owner === 'player' ? w - 40 : 40; else { const t = this.state.units.find(k => k.id === u.targetId); if (t) tx = (t.pos / 100) * w; }
                        this.ctx.lineTo(tx, ty); this.ctx.stroke();
                    }
                    const hp = u.hp / u.maxHp; this.ctx.fillStyle = 'red'; this.ctx.fillRect(x - 8, y - 30, 16, 3); this.ctx.fillStyle = '#0f0'; this.ctx.fillRect(x - 8, y - 30, 16 * hp, 3);
                });
            }
            endGame(r, m) { this.gameOver = true; clearInterval(this.logicInterval); document.getElementById('game-over').style.display = 'flex'; document.getElementById('end-title').innerText = r; document.getElementById('end-title').className = r === 'VICTORY' ? 'text-5xl font-bold mb-4 text-green-500' : 'text-5xl font-bold mb-4 text-red-500'; document.getElementById('end-reason').innerText = m; }
        }
        const game = new Game();
    </script>
</body>

</html>
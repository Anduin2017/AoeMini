<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Êú¥Á¥†Â∏ùÂõΩ - Minimalist Empire</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ‰øùÊåÅÂéüÊúâÁöÑ CSS ‰∏çÂèò */
        body {
            background-color: #111;
            color: #e5e5e5;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            user-select: none;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #game-wrapper {
            position: relative;
            flex: 1;
            overflow: hidden;
            background: #262626;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        #bgCanvas {
            z-index: 5;
        }

        .base {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 64px;
            height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            font-weight: bold;
            font-size: 0.8rem;
            z-index: 10;
            pointer-events: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            border-radius: 8px 8px 4px 4px;
            padding-top: 10px;
        }

        .base::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 26px;
            height: 36px;
            background: #1a1a1a;
            border: 2px solid #444;
            border-bottom: none;
            border-radius: 13px 13px 0 0;
            box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.8);
        }

        #gameCanvas {
            z-index: 15;
        }

        .floater {
            position: absolute;
            color: white;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 1px 1px 2px black;
            z-index: 100;
        }

        .base-player {
            left: 12px;
            background: linear-gradient(to bottom, #3b82f6, #1d4ed8);
            border: 2px solid #1e3a8a;
            border-bottom: 4px solid #1e3a8a;
        }

        .base-enemy {
            right: 12px;
            background: linear-gradient(to bottom, #ef4444, #b91c1c);
            border: 2px solid #7f1d1d;
            border-bottom: 4px solid #7f1d1d;
        }

        .turret-addon {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 15px;
            background-color: #4b5563;
            border: 2px solid #9ca3af;
            border-radius: 4px 4px 0 0;
            display: none;
            z-index: 2;
        }

        .turret-addon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background-color: #000;
            border-radius: 50%;
        }

        .has-turret .turret-addon {
            display: block;
        }

        .hp-bar-container {
            position: absolute;
            top: -25px;
            width: 120%;
            left: -10%;
            height: 6px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .hp-bar-fill {
            height: 100%;
            background: #22c55e;
            width: 100%;
            transition: width 0.2s;
        }

        .base-label {
            position: absolute;
            top: 4px;
            z-index: 3;
            text-shadow: 1px 1px 2px black;
        }

        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px 20px;
            pointer-events: none;
            z-index: 20;
        }

        .top-group {
            display: flex;
            flex-direction: column;
        }

        .top-group.right {
            align-items: flex-end;
        }

        .top-item {
            font-weight: bold;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px black;
            line-height: 1.2;
        }

        .tech-status {
            font-family: monospace;
            font-size: 0.8rem;
            font-weight: bold;
            margin-top: 2px;
            text-shadow: 1px 1px 1px black;
            opacity: 0.9;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px 8px;
        }

        .text-blue {
            color: #60a5fa;
        }

        .text-red {
            color: #f87171;
        }

        .text-blue-light {
            color: #93c5fd;
        }

        .text-red-light {
            color: #fca5a5;
        }

        .tactics-bar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 30;
            pointer-events: auto;
        }

        .tactic-btn {
            background: rgba(30, 30, 30, 0.6);
            border: 1px solid #555;
            color: #ccc;
            padding: 6px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
            font-size: 0.85rem;
        }

        .tactic-btn:hover {
            background: #444;
            color: white;
        }

        .tactic-btn.active {
            background: #2563eb;
            border-color: #60a5fa;
            color: white;
            box-shadow: 0 0 8px #2563eb;
        }

        .resource-widget {
            position: absolute;
            bottom: 100px;
            left: 20px;
            width: 280px;
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            z-index: 40;
            backdrop-filter: blur(8px);
        }

        @media (max-height: 500px) {
            .resource-widget {
                bottom: 90px;
                left: 10px;
                transform: scale(0.9);
                transform-origin: bottom left;
            }
        }

        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            margin-bottom: 8px;
            border-bottom: 1px solid #4b5563;
            font-size: 1rem;
        }

        .status-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .icon-house {
            color: #f59e0b;
        }

        .pop-text {
            font-weight: bold;
            font-family: monospace;
            transition: color 0.2s;
        }

        .pop-text.warning {
            color: #ef4444;
            animation: pulse 1s infinite;
        }

        .icon-sleep {
            color: #9ca3af;
        }

        .idle-text {
            color: #9ca3af;
            font-weight: bold;
            font-family: monospace;
        }

        .idle-text.warning {
            color: #ef4444;
            animation: pulse 1s infinite;
        }

        .res-grid {
            display: grid;
            grid-template-columns: 24px 1fr 24px 50px 24px;
            gap: 4px;
            align-items: center;
            font-size: 0.9rem;
        }

        .res-icon {
            text-align: center;
            font-size: 1rem;
        }

        .res-val {
            font-family: monospace;
            text-align: right;
            padding-right: 10px;
            color: #e5e5e5;
            font-weight: bold;
        }

        .worker-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            height: 24px;
        }

        .res-w-icon {
            color: #9ca3af;
            font-size: 0.7rem;
        }

        .res-w-val {
            color: #60a5fa;
            font-family: monospace;
            font-weight: bold;
        }

        .tiny-btn {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #374151;
            border: 1px solid #4b5563;
            border-radius: 4px;
            cursor: pointer;
            color: #ccc;
            font-size: 0.9rem;
            line-height: 0;
            transition: background 0.1s;
        }

        .tiny-btn:hover {
            background: #4b5563;
            color: white;
        }

        .tiny-btn.disabled {
            opacity: 0.2;
            cursor: default;
            pointer-events: none;
        }

        .dock-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 8px;
            border-radius: 16px;
            display: flex;
            gap: 12px;
            z-index: 50;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            max-width: 95vw;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .dock-container::-webkit-scrollbar {
            display: none;
        }

        .dock-icon {
            width: 56px;
            height: 56px;
            background: #2d2d2d;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            cursor: pointer;
            position: relative;
            transition: transform 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: 1px solid #444;
            flex-shrink: 0;
        }

        .dock-icon:hover {
            transform: translateY(-5px) scale(1.1);
            background: #3d3d3d;
            z-index: 60;
        }

        .dock-icon.active {
            background: #333;
            box-shadow: 0 0 0 2px #3b82f6;
            transform: translateY(-5px);
        }

        .dock-icon.build-icon {
            background: #eab308;
            color: #000;
            border-color: #ca8a04;
        }

        .dock-icon.build-icon:hover {
            background: #facc15;
        }

        .dock-icon.constructing {
            opacity: 0.7;
            border-style: dashed;
            background: #1f2937;
        }

        .dock-icon.constructing .const-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            font-size: 12px;
            color: #eab308;
            font-weight: bold;
        }

        .icon-progress-bg {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            overflow: hidden;
            display: none;
        }

        .icon-progress-fill {
            height: 100%;
            width: 0%;
            background: #3b82f6;
            transition: width linear 0.1s;
        }

        .constructing .icon-progress-fill {
            background: #eab308;
        }

        .dock-icon.researching .icon-progress-fill {
            background: #22c55e;
        }

        .icon-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ef4444;
            color: white;
            font-size: 10px;
            font-weight: bold;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 2px black;
        }

        .icon-badge.house-badge {
            background: #eab308;
            color: #000;
        }

        .popover-menu {
            position: absolute;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid #4b5563;
            border-radius: 8px;
            padding: 10px;
            min-width: 180px;
            display: none;
            flex-direction: column;
            gap: 8px;
            z-index: 60;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(12px);
        }

        .popover-menu::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
            width: 12px;
            height: 12px;
            background: rgba(31, 41, 55, 0.95);
            border-right: 1px solid #4b5563;
            border-bottom: 1px solid #4b5563;
        }

        .popover-title {
            font-size: 0.8rem;
            color: #9ca3af;
            text-transform: uppercase;
            border-bottom: 1px solid #4b5563;
            padding-bottom: 4px;
            margin-bottom: 4px;
            text-align: center;
        }

        .menu-btn {
            background: #374151;
            border: 1px solid #4b5563;
            color: white;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            transition: all 0.1s;
        }

        .menu-btn:hover:not(:disabled) {
            background: #4b5563;
        }

        .menu-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .btn-icon {
            font-size: 1.4rem;
        }

        .btn-info {
            display: flex;
            flex-direction: column;
            line-height: 1.2;
            text-align: left;
        }

        .btn-cost {
            font-size: 0.75rem;
            color: #9ca3af;
        }

        .menu-btn.tech-btn {
            border-color: #8b5cf6;
            background: rgba(139, 92, 246, 0.1);
        }

        .menu-btn.tech-btn:hover:not(:disabled) {
            background: rgba(139, 92, 246, 0.3);
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            display: none;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-30px);
                opacity: 0;
            }
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        #unit-tooltip {
            position: absolute;
            background: rgba(17, 24, 39, 0.95);
            border: 1px solid #4b5563;
            padding: 8px 12px;
            border-radius: 6px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            color: white;
            font-size: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            min-width: 140px;
        }

        .tt-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }

        .tt-header {
            font-weight: bold;
            color: #60a5fa;
            border-bottom: 1px solid #4b5563;
            margin-bottom: 4px;
            padding-bottom: 2px;
            text-align: center;
        }

        .tt-enemy .tt-header {
            color: #f87171;
        }

        .tt-sub {
            color: #9ca3af;
            font-size: 11px;
        }

        .val-bonus {
            color: #22c55e;
            margin-left: 2px;
        }
    </style>
</head>

<body>
    <div id="toast-container" class="fixed top-4 left-1/2 transform -translate-x-1/2 z-50"></div>
    <div class="top-bar">
        <div class="top-group">
            <div class="top-item text-blue">Áé©ÂÆ∂</div>
            <div class="tech-status text-blue-light">
                <span id="p-tech-atk-m" title="ËøëÊàòÊîªÂáª">‚öîÔ∏è 0</span>
                <span id="p-tech-def-m" title="ËøëÊàòÈò≤Âæ°">üõ°Ô∏è 0</span>
                <span id="p-tech-atk-r" title="ËøúÁ®ãÊîªÂáª">üèπ 0</span>
                <span id="p-tech-def-r" title="ËøúÁ®ãÈò≤Âæ°">üéØ 0</span>
            </div>
        </div>
        <div class="top-group right">
            <div class="top-item text-red">ÁîµËÑë</div>
            <div class="tech-status text-red-light">
                <span id="e-tech-atk-m" title="ËøëÊàòÊîªÂáª">‚öîÔ∏è 0</span>
                <span id="e-tech-def-m" title="ËøëÊàòÈò≤Âæ°">üõ°Ô∏è 0</span>
                <span id="e-tech-atk-r" title="ËøúÁ®ãÊîªÂáª">üèπ 0</span>
                <span id="e-tech-def-r" title="ËøúÁ®ãÈò≤Âæ°">üéØ 0</span>
            </div>
        </div>
    </div>
    <div id="game-wrapper">
        <div class="tactics-bar">
            <button id="btn-stance-defend" class="tactic-btn" onclick="game.setPlayerStance('defend')">üõ°Ô∏è Èò≤ÂÆà</button>
            <button id="btn-stance-hold" class="tactic-btn" onclick="game.setPlayerStance('hold')">‚úã ÂæÖÂëΩ</button>
            <button id="btn-stance-attack" class="tactic-btn active" onclick="game.setPlayerStance('attack')">‚öîÔ∏è
                ËøõÊîª</button>
        </div>
        <canvas id="bgCanvas"></canvas>
        <canvas id="gameCanvas"></canvas>
        <div id="unit-tooltip"></div>
        <div id="p-base" class="base base-player">
            <div class="turret-addon"></div>
            <div class="hp-bar-container">
                <div id="p-base-hp" class="hp-bar-fill"></div>
            </div>
            <div class="base-label">Âü∫Âú∞</div>
        </div>
        <div id="e-base" class="base base-enemy">
            <div class="turret-addon"></div>
            <div class="hp-bar-container">
                <div id="e-base-hp" class="hp-bar-fill"></div>
            </div>
            <div class="base-label">ÁîµËÑë</div>
        </div>
    </div>
    <div id="ui-layer">
        <div class="resource-widget">
            <div class="status-header">
                <div class="status-group" title="‰∫∫Âè£"><span class="icon-house">üè†</span> <span id="disp-pop"
                        class="pop-text">0/200</span></div>
                <div class="status-group" title="Á©∫Èó≤ÊùëÊ∞ë"><span class="icon-sleep">üí§</span> <span id="disp-idle"
                        class="idle-text">0</span></div>
            </div>
            <div class="res-grid">
                <div class="res-icon">ü•©</div>
                <div class="res-val" id="res-stock-food">0</div>
                <div class="tiny-btn" id="sub-food" onclick="game.modWork('food',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">üë§</span><span class="res-w-val"
                        id="res-workers-food">0</span></div>
                <div class="tiny-btn" id="add-food" onclick="game.modWork('food',1)">+</div>
                <div class="res-icon">üå≤</div>
                <div class="res-val" id="res-stock-wood">0</div>
                <div class="tiny-btn" id="sub-wood" onclick="game.modWork('wood',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">üë§</span><span class="res-w-val"
                        id="res-workers-wood">0</span></div>
                <div class="tiny-btn" id="add-wood" onclick="game.modWork('wood',1)">+</div>
                <div class="res-icon">ü™ô</div>
                <div class="res-val" id="res-stock-gold">0</div>
                <div class="tiny-btn" id="sub-gold" onclick="game.modWork('gold',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">üë§</span><span class="res-w-val"
                        id="res-workers-gold">0</span></div>
                <div class="tiny-btn" id="add-gold" onclick="game.modWork('gold',1)">+</div>
                <div class="res-icon">ü™®</div>
                <div class="res-val" id="res-stock-stone">0</div>
                <div class="tiny-btn" id="sub-stone" onclick="game.modWork('stone',-1)">-</div>
                <div class="worker-box"><span class="res-w-icon">üë§</span><span class="res-w-val"
                        id="res-workers-stone">0</span></div>
                <div class="tiny-btn" id="add-stone" onclick="game.modWork('stone',1)">+</div>
            </div>
        </div>
        <div class="dock-container" id="dock">
            <div class="dock-icon build-icon" id="dock-build_menu" onclick="game.toggleDockItem('build_menu')">üî®</div>
        </div>
        <div id="popover-container" class="popover-menu"></div>
    </div>
    <div id="game-over">
        <h1 id="end-title" class="text-5xl font-bold mb-4 text-white">GAME OVER</h1>
        <p id="end-reason" class="text-xl text-gray-300 mb-8">Reason</p>
        <button onclick="location.reload()"
            class="px-6 py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded">ÂÜçÊù•‰∏ÄÂ±Ä</button>
    </div>

    <script>
        const TICK_RATE = 100;
        const MAX_QUEUE_SIZE = 5;
        const MAX_TOTAL_POP = 200;
        const BASE_RANGE = 5;

        const CONSTANTS = {
            INITIAL_RES: { food: 200, wood: 200, gold: 100, stone: 0 },
            BASE_HP: 2000, INITIAL_POP_CAP: 10,
            MAP_WIDTH_PERCENT: 100,
            UNIT_SIZE_PERCENT: 0.8,
            BASE_WIDTH_PX: 64,
            BASE_OFFSET_PX: 12,
            UNITS: {
                worker: { cost: { food: 50, wood: 0 }, time: 200, hp: 10, dmg: 0, def_m: 0, def_r: 0, type: 'eco', label: 'ÊùëÊ∞ë', lane: 0, stopOnAttack: false },
                clubman: { cost: { food: 60, wood: 20 }, time: 150, hp: 90, dmg: 8, def_m: 0, def_r: 0, speed: 1.25, type: 'mil', label: 'ÈïøÊû™ÂÖµ', range: BASE_RANGE, lane: 0, stopOnAttack: false, attackType: 'melee', cooldown: 19 },
                samurai: { cost: { food: 100, wood: 0, gold: 20 }, time: 150, hp: 140, dmg: 11, def_m: 2, def_r: 3, speed: 1.125, type: 'mil', label: 'Ê≠¶Â£´', range: BASE_RANGE * 0.75, lane: 0, stopOnAttack: false, attackType: 'melee', cooldown: 14 },
                longbowman: { cost: { food: 40, wood: 50, gold: 0 }, time: 150, hp: 70, dmg: 6, def_m: 0, def_r: 0, speed: 1.125, type: 'mil', label: 'ÈïøÂºìÂÖµ', range: BASE_RANGE * 3, lane: 1, widthScale: 0.5, stopOnAttack: true, attackType: 'ranged', cooldown: 16 }
            },
            BUILDINGS: {
                house: { cost: { food: 0, wood: 50, stone: 0 }, pop: 10, time: 150, label: 'ÊàøÂ±ã', icon: 'üè†' },
                barracks: { cost: { food: 0, wood: 150, stone: 0 }, time: 300, label: 'ÂÖµËê•', icon: '‚öîÔ∏è' },
                archery_range: { cost: { food: 0, wood: 150, stone: 0 }, time: 300, label: 'Èù∂Âú∫', icon: 'üèπ' },
                towncenter: { cost: { food: 0, wood: 400, stone: 350 }, pop: 10, time: 1200, label: 'Âü∫Âú∞', icon: 'üèõÔ∏è' },
                blacksmith: { cost: { food: 0, wood: 150, stone: 0 }, time: 250, label: 'ÈìÅÂå†Èì∫', icon: '‚öíÔ∏è' }
            },
            TECHS: {
                turret_tech: { cost: { food: 0, wood: 0, gold: 100, stone: 170 }, time: 240, label: 'Èò≤Âæ°ÁÇÆÂè∞', icon: 'üèØ', desc: 'Âü∫Âú∞Ëé∑ÂæóÂº∫Â§ßÈò≤Âæ°Âäõ' },
                tech_atk_m_1: { cost: { food: 50, wood: 0, gold: 125, stone: 0 }, time: 600, label: 'ËøëÊàòÊîªÂáª I', icon: '‚öîÔ∏è', level: 1, type: 'atk_m' },
                tech_atk_m_2: { cost: { food: 100, wood: 0, gold: 250, stone: 0 }, time: 600, label: 'ËøëÊàòÊîªÂáª II', icon: '‚öîÔ∏è', level: 2, type: 'atk_m' },
                tech_atk_m_3: { cost: { food: 150, wood: 0, gold: 300, stone: 0 }, time: 600, label: 'ËøëÊàòÊîªÂáª III', icon: '‚öîÔ∏è', level: 3, type: 'atk_m' },
                tech_def_m_1: { cost: { food: 50, wood: 0, gold: 125, stone: 0 }, time: 600, label: 'ËøëÊàòÈò≤Âæ° I', icon: 'üõ°Ô∏è', level: 1, type: 'def_m' },
                tech_def_m_2: { cost: { food: 100, wood: 0, gold: 250, stone: 0 }, time: 600, label: 'ËøëÊàòÈò≤Âæ° II', icon: 'üõ°Ô∏è', level: 2, type: 'def_m' },
                tech_def_m_3: { cost: { food: 150, wood: 0, gold: 300, stone: 0 }, time: 600, label: 'ËøëÊàòÈò≤Âæ° III', icon: 'üõ°Ô∏è', level: 3, type: 'def_m' },
                tech_atk_r_1: { cost: { food: 0, wood: 50, gold: 125, stone: 0 }, time: 600, label: 'ËøúÁ®ãÊîªÂáª I', icon: 'üèπ', level: 1, type: 'atk_r' },
                tech_atk_r_2: { cost: { food: 0, wood: 100, gold: 250, stone: 0 }, time: 600, label: 'ËøúÁ®ãÊîªÂáª II', icon: 'üèπ', level: 2, type: 'atk_r' },
                tech_atk_r_3: { cost: { food: 0, wood: 150, gold: 300, stone: 0 }, time: 600, label: 'ËøúÁ®ãÊîªÂáª III', icon: 'üèπ', level: 3, type: 'atk_r' },
                tech_def_r_1: { cost: { food: 0, wood: 50, gold: 125, stone: 0 }, time: 600, label: 'ËøúÁ®ãÈò≤Âæ° I', icon: 'üéØ', level: 1, type: 'def_r' },
                tech_def_r_2: { cost: { food: 0, wood: 100, gold: 250, stone: 0 }, time: 600, label: 'ËøúÁ®ãÈò≤Âæ° II', icon: 'üéØ', level: 2, type: 'def_r' },
                tech_def_r_3: { cost: { food: 0, wood: 150, gold: 300, stone: 0 }, time: 600, label: 'ËøúÁ®ãÈò≤Âæ° III', icon: 'üéØ', level: 3, type: 'def_r' }
            }
        };

        class Entity {
            constructor(type, owner, id, spawnPos) {
                this.id = id; this.type = type; this.owner = owner;
                const uData = CONSTANTS.UNITS[type];
                this.maxHp = uData.hp;
                this.hp = this.maxHp;
                this.dmg = uData.dmg || 0;
                this.def_m = uData.def_m || 0;
                this.def_r = uData.def_r || 0;
                this.speed = (uData.speed || 0) / (1000 / TICK_RATE);
                this.pos = spawnPos;
                this.state = 'move';
                this.width = CONSTANTS.UNIT_SIZE_PERCENT * (uData.widthScale || 1);
                this.range = uData.range || BASE_RANGE;
                this.lane = uData.lane !== undefined ? uData.lane : 0;
                this.stopOnAttack = uData.stopOnAttack !== undefined ? uData.stopOnAttack : false;
                this.attackCooldown = Math.floor(Math.random() * 10); this.attackAnimTimer = 0;
                this.isDeployed = false;
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.bgCanvas = document.getElementById('bgCanvas');
                this.bgCtx = this.bgCanvas.getContext('2d');
                this.baseWidthPct = 6;
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                this.lastTick = 0; this.entityIdCounter = 0; this.buildingIdCounter = 0; this.constructionIdCounter = 0; this.gameOver = false;
                this.state = {
                    tick: 0,
                    player: this.createFactionState('player'),
                    enemy: this.createFactionState('enemy'),
                    units: [],
                    playerStance: 'attack',
                    enemyStance: 'attack',
                    selectedDockId: null,
                    turretShots: []
                };
                window.addEventListener('click', (e) => { if (!e.target.closest('.dock-icon') && !e.target.closest('.popover-menu')) this.closePopover(); });
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseleave', () => { document.getElementById('unit-tooltip').style.display = 'none'; });
                this.renderDock();
                this.logicInterval = setInterval(() => this.updateLogic(), TICK_RATE);
                setInterval(() => this.debugAI(), 3000);
                requestAnimationFrame(() => this.loop());
            }

            handleMouseMove(e) {
                if (this.gameOver) return;
                const rect = this.canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
                const w = this.canvas.width; const h = this.canvas.height;
                let foundUnit = null;
                for (const u of this.state.units) {
                    const unitX = (u.pos / 100) * w;
                    const laneY = u.lane === 1 ? (h / 2 - 20) : (h / 2 + 20);
                    if (Math.abs(mx - unitX) < 15 && Math.abs(my - laneY) < 20) { foundUnit = u; break; }
                }
                const tt = document.getElementById('unit-tooltip');
                if (foundUnit) {
                    const uData = CONSTANTS.UNITS[foundUnit.type];
                    const isPlayer = foundUnit.owner === 'player';
                    const baseDmg = uData.dmg; const bonusDmg = foundUnit.dmg - baseDmg;
                    tt.className = isPlayer ? '' : 'tt-enemy';
                    tt.innerHTML = `<div class="tt-header">${uData.label} (${isPlayer ? 'ÊàëÊñπ' : 'ÊïåÊñπ'})</div><div class="tt-row"><span>‚ù§Ô∏è ÁîüÂëΩ:</span> <span>${Math.ceil(foundUnit.hp)}/${foundUnit.maxHp}</span></div><div class="tt-row"><span>üó°Ô∏è Âü∫Á°ÄÊîªÂáª:</span> <span>${baseDmg}</span></div><div class="tt-row"><span>üî• ÊîªÂáªÂä†Êàê:</span> <span class="val-bonus">+${bonusDmg}</span></div><div class="tt-row"><span>üõ°Ô∏è ËøëÊàòÈò≤Âæ°:</span> <span>${foundUnit.def_m}</span></div><div class="tt-row"><span>üéØ ËøúÁ®ãÈò≤Âæ°:</span> <span>${foundUnit.def_r}</span></div>`;
                    tt.style.left = (e.clientX + 15) + 'px'; tt.style.top = (e.clientY + 15) + 'px'; tt.style.display = 'block';
                } else {
                    let foundBase = null;
                    const baseYTop = h / 2 - 40; const baseYBottom = h / 2 + 40;
                    const basePxW = CONSTANTS.BASE_WIDTH_PX + CONSTANTS.BASE_OFFSET_PX;
                    if (my >= baseYTop && my <= baseYBottom) {
                        if (mx >= 0 && mx <= basePxW) foundBase = this.state.player;
                        else if (mx >= w - basePxW && mx <= w) foundBase = this.state.enemy;
                    }
                    if (foundBase) {
                        const isPlayer = foundBase.name === 'player';
                        const turretDmg = foundBase.hasTurret ? (CONSTANTS.UNITS.clubman.dmg * 1.5) : 0;
                        tt.className = isPlayer ? '' : 'tt-enemy';
                        tt.innerHTML = `<div class="tt-header">${isPlayer ? 'ÊàëÊñπ' : 'ÊïåÊñπ'}Âü∫Âú∞</div><div class="tt-row"><span>‚ù§Ô∏è ÁîüÂëΩ:</span> <span>${Math.ceil(foundBase.baseHp)}/${CONSTANTS.BASE_HP}</span></div><div class="tt-row"><span>üõ°Ô∏è ËøëÊàòÈò≤Âæ°:</span> <span>2</span></div><div class="tt-row"><span>üéØ ËøúÁ®ãÈò≤Âæ°:</span> <span>2</span></div>${foundBase.hasTurret ? `<div class="tt-row"><span>‚öîÔ∏è ÁÇÆÂè∞:</span> <span>${turretDmg}</span></div>` : ''}`;
                        tt.style.left = (e.clientX + 15) + 'px'; tt.style.top = (e.clientY + 15) + 'px'; tt.style.display = 'block';
                    } else { tt.style.display = 'none'; }
                }
            }

            debugAI() {
                if (this.gameOver) return;
                const ai = this.state.enemy;
                console.groupCollapsed(`ü§ñ AI Áä∂ÊÄÅÁõëÊéß (Tick: ${this.state.tick})`);
                console.log(`üí∞ ËµÑÊ∫ê: F${Math.floor(ai.food)} W${Math.floor(ai.wood)} G${Math.floor(ai.gold)} S${Math.floor(ai.stone)}`);
                console.groupEnd();
            }

            createFactionState(name) {
                const initialBuildings = [{ id: `${name}-b-${this.buildingIdCounter++}`, type: 'towncenter', queue: [] }];
                let initialWorkers = 6; if (name === 'enemy') initialWorkers = 7;
                return {
                    name: name,
                    food: CONSTANTS.INITIAL_RES.food, wood: CONSTANTS.INITIAL_RES.wood, gold: CONSTANTS.INITIAL_RES.gold, stone: CONSTANTS.INITIAL_RES.stone,
                    idleWorkers: 0, assignments: { food: initialWorkers, wood: 0, gold: 0, stone: 0 }, workers: initialWorkers,
                    popCap: CONSTANTS.INITIAL_POP_CAP, baseHp: CONSTANTS.BASE_HP,
                    buildingInstances: initialBuildings, constructions: [], armyCount: 0,
                    hasTurret: false, turretCooldown: 0,
                    techLevels: { atk_m: 0, def_m: 0, atk_r: 0, def_r: 0 }
                };
            }

            resizeCanvas() {
                const wrapper = document.getElementById('game-wrapper');
                const w = wrapper.offsetWidth;
                const h = wrapper.offsetHeight;
                this.canvas.width = w; this.canvas.height = h;
                this.bgCanvas.width = w; this.bgCanvas.height = h;
                const totalBasePx = CONSTANTS.BASE_OFFSET_PX + CONSTANTS.BASE_WIDTH_PX;
                this.baseWidthPct = (totalBasePx / w) * 100;
            }

            toggleDockItem(id) {
                if (this.state.selectedDockId === id) this.closePopover();
                else { this.state.selectedDockId = id; this.buildPopover(); this.updateDockVisuals(); }
            }
            closePopover() {
                this.state.selectedDockId = null;
                document.getElementById('popover-container').style.display = 'none';
                this.updateDockVisuals();
            }

            modWork(type, change) {
                const p = this.state.player;
                if (change > 0) {
                    if (p.idleWorkers > 0) { p.idleWorkers--; p.assignments[type]++; } else this.showToast("Ê≤°ÊúâÁ©∫Èó≤ÊùëÊ∞ë");
                } else {
                    if (p.assignments[type] > 0) { p.assignments[type]--; p.idleWorkers++; }
                }
            }

            updateLogic() {
                if (this.gameOver) return;
                this.state.tick++;
                if (this.state.tick % 10 === 0) {
                    this.gatherResources(this.state.player);
                    this.gatherResources(this.state.enemy);
                    this.runAI();
                }
                this.processBuildingQueues(this.state.player); this.processBuildingQueues(this.state.enemy);
                this.processConstructions(this.state.player); this.processConstructions(this.state.enemy);
                this.state.turretShots = [];
                this.processBaseDefense(this.state.player);
                this.processBaseDefense(this.state.enemy);
                this.updateUnits();
                this.updateUI();
            }

            gatherResources(f) {
                const GATHER_RATE = 0.6;
                f.food += f.assignments.food * GATHER_RATE; f.wood += f.assignments.wood * GATHER_RATE;
                f.gold += f.assignments.gold * GATHER_RATE; f.stone += f.assignments.stone * GATHER_RATE;
            }

            processBuildingQueues(f) {
                f.buildingInstances.forEach(b => {
                    if (b.queue.length > 0) {
                        const item = b.queue[0];
                        if (item.ticksLeft > 0) item.ticksLeft--;
                        if (item.ticksLeft <= 0) {
                            if (CONSTANTS.TECHS[item.type]) {
                                this.completeTech(f, item.type);
                                b.queue.shift();
                                this.refreshPopoverIfSelected(b.id);
                            } else {
                                const uData = CONSTANTS.UNITS[item.type];
                                const currentPop = f.workers + f.armyCount;
                                const isFullPop = (f.name !== 'enemy' && (currentPop >= MAX_TOTAL_POP || currentPop >= f.popCap));

                                // ‰øÆÂ§çÔºöÂÜúÊ∞ë‰∏çÈúÄË¶ÅÊ£ÄÊü•Áâ©ÁêÜÁ¢∞ÊíûÔºåÂè™ÈúÄÊ£ÄÊü•‰∫∫Âè£
                                let isBlocked = false;
                                const spawnPos = f.name === 'player' ? (this.baseWidthPct / 2) : (100 - this.baseWidthPct / 2);

                                if (uData.type !== 'eco') {
                                    // ‰øÆÂ§çÔºöÁ¢∞ÊíûÂà§ÂÆöÊîπ‰∏∫‚ÄúÁâ©ÁêÜÈáçÂè†Ê£ÄÊµã‚ÄùËÄåÈùû‚ÄúËåÉÂõ¥Ê£ÄÊµã‚Äù
                                    // Âà§ÂÆöÊ†áÂáÜÔºöÊñ∞Âçï‰ΩçÁöÑÂçäÂæÑ + Áé∞ÊúâÂçï‰ΩçÁöÑÂçäÂæÑ > ‰∏§ËÄÖË∑ùÁ¶ª
                                    const newUnitWidth = CONSTANTS.UNIT_SIZE_PERCENT * (uData.widthScale || 1);
                                    // ‰ΩøÁî® 0.5 ÁöÑÁ≥ªÊï∞ÔºåÁ°Æ‰øùÊòØÁ¥ßË¥¥ÁùÄËÄå‰∏çÊòØÈáçÂè†
                                    const spacingCheck = (u) => (u.width + newUnitWidth) * 0.5;
                                    isBlocked = this.state.units.some(u => Math.abs(u.pos - spawnPos) < spacingCheck(u));
                                }

                                if (isFullPop || isBlocked) {
                                    item.ticksLeft = 0.1;
                                } else {
                                    this.spawnUnit(f, item.type, spawnPos);
                                    b.queue.shift();
                                    this.refreshPopoverIfSelected(b.id);
                                }
                            }
                        }
                    }
                });
            }

            refreshPopoverIfSelected(bid) { if (this.state.selectedDockId === bid) this.buildPopover(); else if (!this.state.selectedDockId) this.closePopover(); }

            completeTech(f, techId) {
                const tech = CONSTANTS.TECHS[techId];
                if (techId === 'turret_tech') {
                    f.hasTurret = true;
                    if (f.name === 'player') this.showToast("ÁÇÆÂè∞Á≥ªÁªüÂçáÁ∫ßÂÆåÊàê!", "#8b5cf6");
                } else {
                    const typeKey = tech.type;
                    if (f.techLevels[typeKey] !== undefined) {
                        f.techLevels[typeKey] = tech.level;
                        if (f.name === 'player') this.showToast(`${tech.label} Á†îÂèëÂÆåÊàê!`, "#8b5cf6");
                        this.applyTechUpgrade(f, typeKey);
                    }
                }
            }

            applyTechUpgrade(f, typeKey) {
                this.state.units.filter(u => u.owner === f.name && CONSTANTS.UNITS[u.type].type === 'mil').forEach(u => {
                    const uData = CONSTANTS.UNITS[u.type];
                    if (typeKey === 'atk_m' && (!uData.attackType || uData.attackType === 'melee')) u.dmg += 1;
                    if (typeKey === 'atk_r' && uData.attackType === 'ranged') u.dmg += 1;
                    if (typeKey === 'def_m') u.def_m += 1;
                    if (typeKey === 'def_r') u.def_r += 1;
                });
            }

            processBaseDefense(f) {
                if (!f.hasTurret) return;
                if (f.turretCooldown > 0) { f.turretCooldown--; return; }
                const RANGE = BASE_RANGE * 2;
                const DAMAGE = CONSTANTS.UNITS.clubman.dmg * 1.5;
                const COOLDOWN = Math.floor(10 / 1.25);
                const baseWallPos = f.name === 'player' ? this.baseWidthPct : (100 - this.baseWidthPct);
                const enemies = this.state.units.filter(u => u.owner !== f.name);
                const targets = enemies.filter(e => Math.abs(e.pos - baseWallPos) <= RANGE);
                if (targets.length > 0) {
                    f.turretCooldown = COOLDOWN;
                    const shotCount = Math.min(targets.length, 3);
                    for (let i = 0; i < shotCount; i++) {
                        const target = targets[Math.floor(Math.random() * targets.length)];
                        let actualDmg = Math.max(1, DAMAGE - target.def_r);
                        target.hp -= actualDmg;
                        this.spawnFloater(target.pos, `-${actualDmg.toFixed(1)}`, '#f0f');
                        const visualStart = f.name === 'player' ? (this.baseWidthPct / 2) : (100 - this.baseWidthPct / 2);
                        this.state.turretShots.push({ start: visualStart, end: target.pos, color: f.name === 'player' ? '#60a5fa' : '#f87171' });
                    }
                }
            }

            processConstructions(f) {
                const activeConstructions = [];
                let shouldRebuildDock = false;
                f.constructions.forEach(task => {
                    task.ticksLeft--;
                    if (task.ticksLeft <= 0) {
                        if (task.type === 'house' || task.type === 'towncenter') f.popCap = Math.min(f.popCap + (CONSTANTS.BUILDINGS[task.type].pop || 0), MAX_TOTAL_POP);
                        f.buildingInstances.push({ id: `${f.name}-b-${this.buildingIdCounter++}`, type: task.type, queue: [] });
                        if (f.name === 'player') { this.showToast(`${CONSTANTS.BUILDINGS[task.type].label} Âª∫ÈÄ†ÂÆåÊàê`, '#22c55e'); shouldRebuildDock = true; }
                    } else { activeConstructions.push(task); }
                });
                f.constructions = activeConstructions;
                if (shouldRebuildDock) { this.closePopover(); this.renderDock(); }
            }

            spawnUnit(f, type, spawnPos) {
                if (CONSTANTS.UNITS[type].type === 'eco') { f.workers++; f.idleWorkers++; }
                else {
                    f.armyCount++;
                    const u = new Entity(type, f.name, this.entityIdCounter++, spawnPos);
                    if (CONSTANTS.UNITS[type].type === 'mil') {
                        const uData = CONSTANTS.UNITS[type];
                        if (uData.attackType === 'ranged') u.dmg += f.techLevels.atk_r;
                        else u.dmg += f.techLevels.atk_m;
                        u.def_m += f.techLevels.def_m;
                        u.def_r += f.techLevels.def_r;
                    }
                    this.state.units.push(u);
                }
            }

            playerQueueUnit(bid, type) {
                const f = this.state.player; const b = f.buildingInstances.find(i => i.id === bid);
                if (!b) return;
                const unitData = CONSTANTS.UNITS[type];
                if (b.queue.length >= MAX_QUEUE_SIZE) { this.showToast("ÈòüÂàóÂ∑≤Êª°"); return; }
                const costF = unitData.cost.food || 0; const costW = unitData.cost.wood || 0; const costG = unitData.cost.gold || 0;
                if (f.food < costF || f.wood < costW || f.gold < costG) { this.showToast("ËµÑÊ∫ê‰∏çË∂≥"); return; }
                f.food -= costF; f.wood -= costW; f.gold -= costG;
                b.queue.push({ type: type, ticksLeft: unitData.time, totalTicks: unitData.time });
                this.refreshPopoverState();
            }

            playerQueueTech(bid, techId) {
                const f = this.state.player; const b = f.buildingInstances.find(i => i.id === bid);
                if (!b) return;
                const tech = CONSTANTS.TECHS[techId];
                if (b.queue.length > 0) { this.showToast("ÈòüÂàó‰∏ç‰∏∫Á©∫"); return; }
                if (f.food < tech.cost.food || f.wood < tech.cost.wood || f.gold < tech.cost.gold || f.stone < tech.cost.stone) { this.showToast("ËµÑÊ∫ê‰∏çË∂≥"); return; }
                f.food -= (tech.cost.food || 0); f.wood -= (tech.cost.wood || 0); f.gold -= (tech.cost.gold || 0); f.stone -= (tech.cost.stone || 0);
                b.queue.push({ type: techId, ticksLeft: tech.time, totalTicks: tech.time });
                this.showToast("Á†îÂèë: " + tech.label, "#8b5cf6");
                this.closePopover();
            }

            playerBuildStructure(type) {
                const f = this.state.player; const d = CONSTANTS.BUILDINGS[type];
                if (type === 'house' && f.popCap >= MAX_TOTAL_POP) { this.showToast("‰∫∫Âè£Â∑≤Ëææ‰∏äÈôê"); return; }
                const sCost = d.cost.stone || 0;
                if (f.food < d.cost.food || f.wood < d.cost.wood || f.stone < sCost) { this.showToast("ËµÑÊ∫ê‰∏çË∂≥"); return; }
                f.food -= d.cost.food; f.wood -= d.cost.wood; f.stone -= sCost;
                f.constructions.push({ id: this.constructionIdCounter++, type: type, ticksLeft: d.time, totalTicks: d.time });
                this.showToast(`ÂºÄÂßãÂª∫ÈÄ† ${d.label}`);
                this.closePopover(); this.renderDock();
            }

            setPlayerStance(s) {
                this.state.playerStance = s;
                ['defend', 'hold', 'attack'].forEach(k => { document.getElementById(`btn-stance-${k}`).className = `tactic-btn ${k === s ? 'active' : ''}`; });
            }

            runAI() {
                const ai = this.state.enemy;
                ai.assignments = { food: 0, wood: 0, gold: 0, stone: 0 }; ai.idleWorkers = 0;
                const resources = [{ type: 'food', amount: ai.food }, { type: 'wood', amount: ai.wood }, { type: 'gold', amount: ai.gold }];
                resources.sort((a, b) => a.amount - b.amount); ai.assignments[resources[0].type] = ai.workers;
                const eUnits = this.state.units.filter(u => u.owner === 'enemy');
                const pUnits = this.state.units.filter(u => u.owner === 'player');
                let playerFront = 0; if (pUnits.length > 0) playerFront = Math.max(...pUnits.map(u => u.pos));
                let enemyFront = 100; if (eUnits.length > 0) enemyFront = Math.min(...eUnits.map(u => u.pos));
                const distance = enemyFront - playerFront; const battleLine = (playerFront + enemyFront) / 2;

                // ‰øÆÂ§çÔºöÂ¶ÇÊûúAIÊúâÂª∫Á≠ëÈòªÂ°ûÔºåÂº∫Âà∂ÂàáÊç¢‰∏∫ËøõÊîª‰ª•ÁñèÈÄö
                let isJammed = false;
                ai.buildingInstances.forEach(b => {
                    if (b.queue.length > 0 && b.queue[0].ticksLeft <= 0.2) isJammed = true;
                });

                // AI Logic condensed
                const blacksmith = ai.buildingInstances.find(b => b.type === 'blacksmith');
                let savingForTech = false;
                if ((ai.armyCount > 5 || battleLine < 40) && blacksmith && blacksmith.queue.length === 0) {
                    let targetTech = null;
                    const levels = ai.techLevels;
                    if (levels.atk_m < 1) targetTech = 'tech_atk_m_1';
                    else if (levels.def_m < 1) targetTech = 'tech_def_m_1';
                    // ... (simplified AI decision tree)

                    if (targetTech) {
                        const t = CONSTANTS.TECHS[targetTech];
                        if (ai.food >= (t.cost.food || 0) && ai.wood >= (t.cost.wood || 0) && ai.gold >= (t.cost.gold || 0) && ai.stone >= (t.cost.stone || 0)) {
                            ai.food -= (t.cost.food || 0); ai.wood -= (t.cost.wood || 0); ai.gold -= (t.cost.gold || 0); ai.stone -= (t.cost.stone || 0);
                            blacksmith.queue.push({ type: targetTech, ticksLeft: t.time, totalTicks: t.time });
                        } else savingForTech = true;
                    }
                }

                if (!savingForTech) {
                    let pendingWorkers = 0; ai.buildingInstances.forEach(b => b.queue.forEach(q => { if (q.type === 'worker') pendingWorkers++; }));
                    ai.buildingInstances.forEach(b => {
                        if (b.queue.length < 5) {
                            if (b.type === 'towncenter' && ai.workers + pendingWorkers < 60) { this.aiQueue(ai, b, 'worker'); pendingWorkers++; }
                            else if (b.type === 'barracks') this.aiQueue(ai, b, 'clubman');
                            else if (b.type === 'archery_range') this.aiQueue(ai, b, 'longbowman');
                        }
                    });
                }
                // AI Build logic
                const countType = (t) => ai.buildingInstances.filter(b => b.type === t).length + ai.constructions.filter(c => c.type === t).length;
                let structureToBuild = null;
                if (countType('barracks') < 1) structureToBuild = 'barracks';
                else if (countType('archery_range') < 1) structureToBuild = 'archery_range';
                else if (countType('blacksmith') < 1) structureToBuild = 'blacksmith';
                else if (countType('barracks') < 4 || ai.wood > 600) structureToBuild = 'barracks';
                if (structureToBuild) this.aiBuild(ai, structureToBuild);

                let newStance = 'attack';
                if (isJammed) {
                    newStance = 'attack'; // ÈòªÂ°ûÊó∂Âº∫Âà∂ËøõÊîª
                } else {
                    if (eUnits.length > pUnits.length) newStance = 'attack';
                    else if (distance < 30 && battleLine > 65) newStance = 'defend';
                }
                if (this.state.enemyStance !== newStance) this.state.enemyStance = newStance;
            }

            aiBuild(f, t) {
                const d = CONSTANTS.BUILDINGS[t]; const s = d.cost.stone || 0;
                if (f.food >= d.cost.food && f.wood >= d.cost.wood && f.stone >= s) {
                    f.food -= d.cost.food; f.wood -= d.cost.wood; f.stone -= s;
                    f.constructions.push({ id: Math.random(), type: t, ticksLeft: d.time, totalTicks: d.time });
                }
            }
            aiQueue(f, b, u) {
                const d = CONSTANTS.UNITS[u];
                if (f.food >= d.cost.food && f.wood >= d.cost.wood && f.gold >= (d.cost.gold || 0)) {
                    f.food -= d.cost.food; f.wood -= d.cost.wood; f.gold -= (d.cost.gold || 0);
                    b.queue.push({ type: u, ticksLeft: d.time, totalTicks: d.time });
                }
            }

            updateUI() {
                const p = this.state.player; const e = this.state.enemy;
                document.getElementById('p-base-hp').style.width = Math.max(0, (p.baseHp / CONSTANTS.BASE_HP * 100)) + '%';
                document.getElementById('e-base-hp').style.width = Math.max(0, (e.baseHp / CONSTANTS.BASE_HP * 100)) + '%';
                if (p.hasTurret) document.getElementById('p-base').classList.add('has-turret');
                if (e.hasTurret) document.getElementById('e-base').classList.add('has-turret');
                // Tech & Res updates skipped for brevity (same as before)
                const currentPop = p.workers + p.armyCount;
                const popEl = document.getElementById('disp-pop');
                popEl.innerText = `${currentPop}/${p.popCap}`;

                // ÊÅ¢Â§ç‰∫∫Âè£È¢úËâ≤ÈÄªËæë
                if (currentPop >= p.popCap) {
                    popEl.style.color = '#ef4444';
                    popEl.classList.add('warning');
                } else {
                    popEl.classList.remove('warning');
                    if (currentPop >= p.popCap * 0.8) {
                        popEl.style.color = '#eab308';
                    } else {
                        popEl.style.color = '#e5e5e5';
                    }
                }

                document.getElementById('disp-idle').innerText = p.idleWorkers;
                if (p.idleWorkers > 0) document.getElementById('disp-idle').classList.add('warning');
                else document.getElementById('disp-idle').classList.remove('warning');

                ['food', 'wood', 'gold', 'stone'].forEach(r => {
                    document.getElementById(`res-stock-${r}`).innerText = Math.floor(p[r]);
                    document.getElementById(`res-workers-${r}`).innerText = p.assignments[r];
                    const btnAdd = document.getElementById(`add-${r}`);
                    const btnSub = document.getElementById(`sub-${r}`);
                    if (p.idleWorkers > 0) btnAdd.classList.remove('disabled'); else btnAdd.classList.add('disabled');
                    if (p.assignments[r] > 0) btnSub.classList.remove('disabled'); else btnSub.classList.add('disabled');
                });
                this.updateDockProgress();
                if (this.state.selectedDockId) this.refreshPopoverState();
            }

            renderDock() { /* ... Same as before ... */
                const dock = document.getElementById('dock'); dock.innerHTML = ''; const p = this.state.player;
                const mixedList = [...p.buildingInstances.filter(b => b.type !== 'house').map(b => ({ ...b, isConstruction: false })), ...p.constructions.map(c => ({ ...c, isConstruction: true }))];

                // ÊÅ¢Â§çÂõ∫ÂÆöÁöÑÊéíÂ∫èÈÄªËæë
                mixedList.sort((a, b) => {
                    const order = { towncenter: 1, barracks: 2, archery_range: 3, blacksmith: 4 };
                    return (order[a.type] || 99) - (order[b.type] || 99);
                });

                mixedList.forEach(item => {
                    const icon = this.createDockIcon(item.isConstruction ? `const-${item.id}` : item.id, CONSTANTS.BUILDINGS[item.type].icon, item.isConstruction);
                    if (!item.isConstruction) icon.onclick = () => this.toggleDockItem(item.id);
                    dock.appendChild(icon);
                });
                // Houses & Build Menu
                const houses = p.buildingInstances.filter(b => b.type === 'house');
                if (houses.length > 0) { const icon = this.createDockIcon('group-house', 'üè†', false); icon.onclick = () => this.toggleDockItem('group-house'); icon.querySelector('.icon-badge').style.display = 'flex'; icon.querySelector('.icon-badge').innerText = houses.length; dock.appendChild(icon); }
                const hammer = this.createDockIcon('dock-build_menu', 'üî®', false); hammer.classList.add('build-icon'); hammer.onclick = () => this.toggleDockItem('build_menu'); dock.appendChild(hammer);
                this.updateDockVisuals();
            }

            createDockIcon(id, emoji, isConstructing) {
                const icon = document.createElement('div'); icon.className = `dock-icon ${isConstructing ? 'constructing' : ''}`;
                icon.id = `dock-elem-${id}`; icon.dataset.refId = id; icon.innerHTML = emoji;
                if (isConstructing) { const overlay = document.createElement('div'); overlay.className = 'const-overlay'; icon.appendChild(overlay); }
                const barBg = document.createElement('div'); barBg.className = 'icon-progress-bg'; const barFill = document.createElement('div'); barFill.className = 'icon-progress-fill'; barBg.appendChild(barFill); icon.appendChild(barBg);
                const badge = document.createElement('div'); badge.className = 'icon-badge'; badge.style.display = 'none'; icon.appendChild(badge);
                return icon;
            }
            updateDockProgress() { /* ... Same as before ... */
                const p = this.state.player;
                p.buildingInstances.forEach(b => {
                    if (b.type === 'house') return;
                    const el = document.getElementById(`dock-elem-${b.id}`);
                    if (el) {
                        const bar = el.querySelector('.icon-progress-fill'); const badge = el.querySelector('.icon-badge');
                        if (b.queue.length > 0) {
                            const t = b.queue[0];
                            if (t.ticksLeft <= 0.2 && t.ticksLeft > 0) { bar.style.width = '100%'; bar.style.backgroundColor = '#ef4444'; }
                            else { bar.style.width = (100 - (t.ticksLeft / t.totalTicks * 100)) + '%'; bar.style.backgroundColor = CONSTANTS.TECHS[t.type] ? '#22c55e' : '#3b82f6'; }
                            el.querySelector('.icon-progress-bg').style.display = 'block'; badge.style.display = 'flex'; badge.innerText = b.queue.length;
                        } else { bar.style.width = '0%'; el.querySelector('.icon-progress-bg').style.display = 'none'; badge.style.display = 'none'; }
                    }
                });
                // Constructions progress
                p.constructions.forEach(c => {
                    const el = document.getElementById(`dock-elem-const-${c.id}`);
                    if (el) { const bar = el.querySelector('.icon-progress-fill'); const pct = Math.floor(100 - (c.ticksLeft / c.totalTicks * 100)); bar.style.width = pct + '%'; el.querySelector('.const-overlay').innerText = pct + '%'; el.querySelector('.icon-progress-bg').style.display = 'block'; }
                });
            }
            updateDockVisuals() { /* Same */
                Array.from(document.getElementById('dock').children).forEach(el => {
                    const lid = el.id === 'dock-elem-dock-build_menu' ? 'build_menu' : el.dataset.refId;
                    if (this.state.selectedDockId === lid) el.classList.add('active'); else el.classList.remove('active');
                });
            }
            buildPopover() { /* Same logic, UI rendering */
                const container = document.getElementById('popover-container');
                const id = this.state.selectedDockId; if (!id) { container.style.display = 'none'; return; }
                container.innerHTML = ''; container.style.display = 'flex';
                const p = this.state.player;
                if (id === 'build_menu') {
                    container.innerHTML = `<div class="popover-title">Âª∫ÈÄ†</div>`;
                    ['house', 'barracks', 'archery_range', 'blacksmith', 'towncenter'].forEach(t => {
                        const d = CONSTANTS.BUILDINGS[t];
                        const btn = document.createElement('div'); btn.className = 'menu-btn build-action-btn'; btn.dataset.type = t; btn.onclick = () => this.playerBuildStructure(t);
                        let cost = []; if (d.cost.food) cost.push(`${d.cost.food}ËÇâ`); if (d.cost.wood) cost.push(`${d.cost.wood}Êú®`); if (d.cost.stone) cost.push(`${d.cost.stone}Áü≥`);
                        btn.innerHTML = `<span class="btn-icon">${d.icon}</span><div class="btn-info"><span>${d.label}</span><span class="btn-cost">${cost.join(' ')}</span></div>`;
                        container.appendChild(btn);
                    });
                } else if (id !== 'group-house') {
                    const b = p.buildingInstances.find(x => x.id === id);
                    if (b) {
                        const buildingLabel = CONSTANTS.BUILDINGS[b.type].label;
                        container.innerHTML = `<div class="popover-title">${buildingLabel}</div><div id="popover-prog-status" class="text-xs text-blue-400 text-center mb-2 font-bold" style="display:none;"></div>`;
                        // Produce buttons logic...
                        let unitTypes = [];
                        if (b.type === 'towncenter') unitTypes = ['worker'];
                        else if (b.type === 'barracks') unitTypes = ['clubman', 'samurai'];
                        else if (b.type === 'archery_range') unitTypes = ['longbowman'];
                        unitTypes.forEach(uType => {
                            const u = CONSTANTS.UNITS[uType];
                            const btn = document.createElement('div'); btn.className = 'menu-btn produce-action-btn'; btn.dataset.type = uType;
                            btn.onclick = () => this.playerQueueUnit(id, uType);
                            let cost = []; if (u.cost.food) cost.push(`${u.cost.food}ËÇâ`); if (u.cost.wood) cost.push(`${u.cost.wood}Êú®`); if (u.cost.gold) cost.push(`${u.cost.gold}Èáë`);
                            btn.innerHTML = `<span class="btn-icon">${uType === 'worker' ? 'üë∑' : (uType === 'longbowman' ? 'üèπ' : '‚öîÔ∏è')}</span><div class="btn-info"><span>ËÆ≠ÁªÉ${u.label}</span><span class="btn-cost">${cost.join(' ')}</span></div>`;
                            container.appendChild(btn);
                        });
                        // Tech buttons...
                        // (Tech rendering logic abbreviated for safety, refer to prev good state)
                        if (b.type === 'towncenter' && !p.hasTurret && !p.buildingInstances.some(bi => bi.queue.some(q => q.type === 'turret_tech'))) {
                            const tech = CONSTANTS.TECHS.turret_tech;
                            const tBtn = document.createElement('div'); tBtn.className = 'menu-btn tech-btn'; tBtn.dataset.tech = 'turret_tech'; tBtn.onclick = () => this.playerQueueTech(id, 'turret_tech');
                            tBtn.innerHTML = `<span class="btn-icon">${tech.icon}</span><div class="btn-info"><span>Á†îÂèë${tech.label}</span><span class="btn-cost">${tech.cost.gold}Èáë ${tech.cost.stone}Áü≥</span></div>`;
                            container.appendChild(tBtn);
                        }
                        if (b.type === 'blacksmith') {
                            // Blacksmith tech logic
                            const levels = p.techLevels;
                            ['atk_m', 'def_m', 'atk_r', 'def_r'].forEach(type => {
                                const nextLvl = levels[type] + 1;
                                const techId = `tech_${type}_${nextLvl}`;
                                const tech = CONSTANTS.TECHS[techId];
                                if (levels[type] < 3 && tech && !p.buildingInstances.some(bi => bi.queue.some(q => q.type === techId))) {
                                    const tBtn = document.createElement('div'); tBtn.className = 'menu-btn tech-btn'; tBtn.dataset.tech = techId; tBtn.onclick = () => this.playerQueueTech(id, techId);
                                    let cost = []; if (tech.cost.food) cost.push(tech.cost.food + 'ËÇâ'); if (tech.cost.wood) cost.push(tech.cost.wood + 'Êú®'); if (tech.cost.gold) cost.push(tech.cost.gold + 'Èáë');
                                    tBtn.innerHTML = `<span class="btn-icon">${tech.icon}</span><div class="btn-info"><span>${tech.label}</span><span class="btn-cost">${cost.join(' ')}</span></div>`;
                                    container.appendChild(tBtn);
                                }
                            });
                        }
                        const q = document.createElement('div'); q.id = 'popover-queue-info'; q.className = 'text-xs text-gray-400 text-center mt-1'; container.appendChild(q);
                    }
                }
                this.refreshPopoverState();
                const icon = document.getElementById(this.state.selectedDockId === 'build_menu' ? 'dock-elem-dock-build_menu' : `dock-elem-${this.state.selectedDockId}`);
                if (icon) { const rect = icon.getBoundingClientRect(); container.style.left = (rect.left + rect.width / 2) + 'px'; }
            }

            refreshPopoverState() { /* Same logic as previous */
                const id = this.state.selectedDockId; if (!id || id === 'group-house') return;
                const p = this.state.player;
                if (id === 'build_menu') {
                    document.querySelectorAll('.build-action-btn').forEach(btn => {
                        const t = btn.dataset.type; const d = CONSTANTS.BUILDINGS[t];
                        const s = d.cost.stone || 0; const f = d.cost.food || 0; const w = d.cost.wood || 0;
                        if (p.food >= f && p.wood >= w && p.stone >= s) btn.removeAttribute('disabled'); else btn.setAttribute('disabled', 'true');
                    });
                } else {
                    const b = p.buildingInstances.find(x => x.id === id);
                    if (!b) { this.closePopover(); return; }
                    const statusEl = document.getElementById('popover-prog-status');
                    if (statusEl) {
                        if (b.queue.length > 0) {
                            const item = b.queue[0];
                            if (item.ticksLeft <= 0.2) { statusEl.innerText = `‚ö†Ô∏è Áîü‰∫ßÈòªÂ°û`; statusEl.style.color = '#ef4444'; }
                            else { statusEl.innerText = `Áîü‰∫ß‰∏≠...`; statusEl.style.color = '#3b82f6'; }
                            statusEl.style.display = 'block';
                        } else statusEl.style.display = 'none';
                    }
                    const qInfo = document.getElementById('popover-queue-info'); if (qInfo) qInfo.innerText = `ÈòüÂàó: ${b.queue.length}`;
                }
            }

            updateUnits() {
                let p = this.state.units.filter(u => u.owner === 'player');
                let e = this.state.units.filter(u => u.owner === 'enemy').sort((a, b) => a.pos - b.pos);
                if (this.state.playerStance === 'attack') p.sort((a, b) => b.pos - a.pos); else p.sort((a, b) => a.pos - b.pos);

                // Create separate collision lists BEFORE processing logic
                const pForCollision = [...p].sort((a, b) => b.pos - a.pos);
                const eForCollision = [...e];

                p.forEach((u, i) => {
                    this.processCombat(u, e, 1);
                    const friendsInLane = p.filter(f => f.lane === u.lane);
                    const laneIndex = friendsInLane.findIndex(f => f.id === u.id);
                    this.processMovement(u, friendsInLane, eForCollision, laneIndex, 1);
                });
                e.forEach((u, i) => {
                    this.processCombat(u, p, -1);
                    const friendsInLane = e.filter(f => f.lane === u.lane);
                    const laneIndex = friendsInLane.findIndex(f => f.id === u.id);
                    this.processMovement(u, friendsInLane, pForCollision, laneIndex, -1);
                });

                const dead = this.state.units.filter(u => u.hp <= 0);
                dead.forEach(u => this.handleUnitDeath(u));
                this.state.units = this.state.units.filter(u => u.hp > 0);
                if (this.state.player.baseHp <= 0) this.endGame('DEFEAT', '‰Ω†ÁöÑÂ∏ùÂõΩÈô∑ËêΩ‰∫Ü„ÄÇ');
                if (this.state.enemy.baseHp <= 0) this.endGame('VICTORY', '‰Ω†ÂæÅÊúç‰∫ÜÈáéËõÆ‰∫∫ÔºÅ');
            }

            handleUnitDeath(u) { /* Same as before */
                const f = u.owner === 'player' ? this.state.player : this.state.enemy;
                if (CONSTANTS.UNITS[u.type].type === 'eco') {
                    if (f.workers > 0) { f.workers--; if (f.idleWorkers > 0) f.idleWorkers--; else { for (const r of ['stone', 'gold', 'wood', 'food']) if (f.assignments[r] > 0) { f.assignments[r]--; break; } } }
                } else { f.armyCount = Math.max(0, f.armyCount - 1); }
            }

            processCombat(u, ens, dir) {
                if (u.attackAnimTimer > 0) u.attackAnimTimer--; if (u.attackCooldown > 0) u.attackCooldown--;

                // Logic Fix: Don't target enemies behind the wall if you are a melee unit
                const uData = CONSTANTS.UNITS[u.type];
                const isMelee = !uData.attackType || uData.attackType === 'melee';
                const wallPos = dir === 1 ? (100 - this.baseWidthPct) : this.baseWidthPct;

                let v = ens.filter(e => {
                    // Range check
                    if (Math.abs(u.pos - e.pos) > u.range) return false;
                    // Wall Line-of-Sight check for Melee
                    if (isMelee) {
                        // If I am outside (attacker), and he is inside (target)
                        if (dir === 1) { // Player attacking right
                            if (u.pos < wallPos && e.pos > wallPos) return false;
                        } else { // Enemy attacking left
                            if (u.pos > wallPos && e.pos < wallPos) return false;
                        }
                    }
                    return true;
                });

                let t = null;
                if (v.length > 0) {
                    v.sort((a, b) => Math.abs(u.pos - a.pos) - Math.abs(u.pos - b.pos));
                    t = v[0];
                } else {
                    const targetBaseWall = dir === 1 ? (100 - this.baseWidthPct) : this.baseWidthPct;
                    if (Math.abs(u.pos - targetBaseWall) <= u.range) t = "base";
                }

                if (t) {
                    u.state = 'attack'; u.targetId = (t === "base") ? "base" : t.id;
                    if (u.attackCooldown <= 0) {
                        u.attackCooldown = CONSTANTS.UNITS[u.type].cooldown || 10;
                        u.attackAnimTimer = 3; const dmg = u.dmg;
                        if (t === "base") {
                            const baseDef = 2; const actualDmg = Math.max(1, dmg - baseDef);
                            if (u.owner === 'player') this.state.enemy.baseHp -= actualDmg; else this.state.player.baseHp -= actualDmg;
                            const floatPos = dir === 1 ? (100 - this.baseWidthPct) : this.baseWidthPct;
                            this.spawnFloater(floatPos, `-${actualDmg}`, '#f00');
                        } else {
                            const uData = CONSTANTS.UNITS[u.type]; const atkType = uData.attackType || 'melee';
                            let defVal = (atkType === 'ranged') ? t.def_r : t.def_m;
                            let actualDmg = Math.max(1, dmg - defVal);
                            t.hp -= actualDmg; this.spawnFloater(t.pos, `-${actualDmg}`, '#fff');
                        }
                    }
                } else { u.state = 'move'; }
            }

            processMovement(u, friends, enemies, i, dir) {
                if (u.stopOnAttack && u.state === 'attack') return;

                // Deployed Logic: Once deployed, cannot go back into base
                const myBaseWall = u.owner === 'player' ? this.baseWidthPct : (100 - this.baseWidthPct);
                if (!u.isDeployed) {
                    if (u.owner === 'player' && u.pos > myBaseWall + 1) u.isDeployed = true;
                    if (u.owner === 'enemy' && u.pos < myBaseWall - 1) u.isDeployed = true;
                }

                let d = u.pos;
                const s = u.owner === 'player' ? this.state.playerStance : this.state.enemyStance;
                let speed = u.speed; if (dir === -1) speed = -speed;

                // Potential Next Position
                let nextD = d;

                if (s === 'attack') {
                    nextD += speed;
                    // 1. Limit by Friends
                    if (i > 0) {
                        const l = friends[i - 1].pos - (dir * u.width);
                        if (dir === 1 ? nextD > l : nextD < l) nextD = l;
                    }
                    // 2. Limit by Enemies
                    if (enemies.length > 0) {
                        const l = enemies[0].pos - (dir * u.width);
                        if (dir === 1 ? nextD > l : nextD < l) nextD = l;
                    }
                    // 3. Limit by Wall (The fix: this is mandatory, not else)
                    const enemyWallPos = dir === 1 ? (100 - this.baseWidthPct) : this.baseWidthPct;
                    // Stop slightly before the wall (padding 2)
                    if (dir === 1) {
                        if (nextD > enemyWallPos - 2) nextD = enemyWallPos - 2;
                    } else {
                        if (nextD < enemyWallPos + 2) nextD = enemyWallPos + 2;
                    }
                } else {
                    // Defend/Hold
                    if (s === 'defend') nextD -= speed;

                    if (dir === 1) { // Player
                        let limit = 0;
                        if (u.isDeployed) limit = this.baseWidthPct + 1; // Can't re-enter base
                        if (i > 0) limit = Math.max(limit, friends[i - 1].pos + u.width);
                        if (nextD < limit) nextD = limit;
                    } else { // Enemy
                        let limit = 100;
                        if (u.isDeployed) limit = (100 - this.baseWidthPct) - 1;
                        if (i < friends.length - 1) limit = Math.min(limit, friends[i + 1].pos - u.width);
                        if (nextD > limit) nextD = limit;
                    }
                }
                u.pos = nextD;
            }

            spawnFloater(x, t, c) { const el = document.createElement('div'); el.className = 'floater'; const r = document.getElementById('game-wrapper').getBoundingClientRect(); el.style.left = (x / 100 * r.width) + 'px'; el.style.top = (r.height / 2 - 20) + 'px'; el.style.color = c; el.innerText = t; document.getElementById('game-wrapper').appendChild(el); setTimeout(() => el.remove(), 1000); }
            showToast(msg, c = '#ef4444') { const el = document.createElement('div'); el.className = 'toast text-white px-4 py-2 rounded shadow-lg font-bold'; el.style.background = c; el.innerText = msg; document.getElementById('toast-container').appendChild(el); setTimeout(() => el.remove(), 2000); }
            loop() { if (!this.gameOver) { this.draw(); requestAnimationFrame(() => this.loop()); } }
            draw() {
                const w = this.canvas.width; const h = this.canvas.height;
                this.ctx.clearRect(0, 0, w, h); this.bgCtx.clearRect(0, 0, w, h);
                this.bgCtx.strokeStyle = '#555'; this.bgCtx.beginPath(); this.bgCtx.moveTo(0, h / 2 - 20); this.bgCtx.lineTo(w, h / 2 - 20); this.bgCtx.stroke(); this.bgCtx.beginPath(); this.bgCtx.moveTo(0, h / 2 + 20); this.bgCtx.lineTo(w, h / 2 + 20); this.bgCtx.stroke();
                this.state.turretShots.forEach(shot => { this.ctx.strokeStyle = shot.color; this.ctx.lineWidth = 3; this.ctx.beginPath(); this.ctx.moveTo((shot.start / 100) * w, h / 2 - 20); this.ctx.lineTo((shot.end / 100) * w, h / 2); this.ctx.stroke(); this.ctx.fillStyle = 'white'; this.ctx.beginPath(); this.ctx.arc((shot.end / 100) * w, h / 2, 5, 0, Math.PI * 2); this.ctx.fill(); });
                this.state.units.forEach(u => {
                    const x = (u.pos / 100) * w; const laneY = u.lane === 1 ? (h / 2 - 20) : (h / 2 + 20);
                    this.ctx.fillStyle = u.owner === 'player' ? '#3b82f6' : '#ef4444';
                    if (u.type === 'samurai') this.ctx.fillRect(x - 8, laneY - 20, 16, 20);
                    else if (u.type === 'clubman') { this.ctx.beginPath(); this.ctx.arc(x, laneY - 8, 8, 0, Math.PI * 2); this.ctx.fill(); }
                    else if (u.type === 'longbowman') { this.ctx.fillStyle = u.owner === 'player' ? '#8b5cf6' : '#a855f7'; this.ctx.beginPath(); this.ctx.moveTo(x, laneY - 20); this.ctx.lineTo(x - 6, laneY); this.ctx.lineTo(x + 6, laneY); this.ctx.fill(); }
                    else this.ctx.fillRect(x - 5, laneY - 15, 10, 15);
                    this.ctx.fillStyle = '#ccc';
                    if (u.type === 'clubman') this.ctx.fillRect(u.owner === 'player' ? x + 2 : x - 12, laneY - 10, 10, 2);
                    else if (u.type !== 'longbowman') this.ctx.fillRect(u.owner === 'player' ? x + 5 : x - 5, laneY - 15, 8, 2);
                    if (u.attackAnimTimer > 0) {
                        this.ctx.strokeStyle = '#ffff00'; this.ctx.lineWidth = 2; this.ctx.beginPath();
                        this.ctx.moveTo(u.owner === 'player' ? x + 5 : x - 5, laneY - 15 + (Math.random() * 6 - 3));
                        let tx = u.owner === 'player' ? x + 30 : x - 30; let ty = laneY - 10;
                        if (u.targetId === "base") tx = u.owner === 'player' ? (100 - this.baseWidthPct) / 100 * w : (this.baseWidthPct / 100) * w;
                        else { const t = this.state.units.find(k => k.id === u.targetId); if (t) { tx = (t.pos / 100) * w; const targetLaneY = t.lane === 1 ? (h / 2 - 20) : (h / 2 + 20); ty = targetLaneY - 10; } }
                        this.ctx.lineTo(tx, ty); this.ctx.stroke();
                    }
                    const hp = u.hp / u.maxHp; this.ctx.fillStyle = 'red'; this.ctx.fillRect(x - 8, laneY - 25, 16, 3); this.ctx.fillStyle = '#0f0'; this.ctx.fillRect(x - 8, laneY - 25, 16 * hp, 3);
                });
            }
            endGame(r, m) { this.gameOver = true; clearInterval(this.logicInterval); document.getElementById('game-over').style.display = 'flex'; document.getElementById('end-title').innerText = r; document.getElementById('end-title').className = r === 'VICTORY' ? 'text-5xl font-bold mb-4 text-green-500' : 'text-5xl font-bold mb-4 text-red-500'; document.getElementById('end-reason').innerText = m; }
        }
        const game = new Game();
        window.show_me_the_money = function () { if (game && game.state && game.state.player) { game.state.player.food = 9999; game.state.player.wood = 9999; game.state.player.gold = 9999; game.state.player.stone = 9999; game.updateUI(); console.log("Resources granted: 9999 [Food, Wood, Gold, Stone]"); } }
    </script>
</body>

</html>